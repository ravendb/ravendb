﻿using System.Linq;
using System.Net;
﻿using System;
using System.IO.Compression;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading.Tasks;
using Raven.Client.Documents.Operations.ETL;
using Raven.Client.Documents.Operations.OngoingTasks;
using Raven.Client.Documents.Operations.Replication;
using Raven.Client.Exceptions;
using Raven.Client.Json.Converters;
using Raven.Server.Json;
using Raven.Server.Routing;
using Raven.Server.ServerWide.Commands;
using Raven.Server.ServerWide.Commands.ConnectionStrings;
using Raven.Server.ServerWide.Context;
using Raven.Server.Utils;
using Raven.Server.Web.System;
using Sparrow.Json;
using Sparrow.Json.Parsing;

namespace Raven.Server.Documents.Handlers
{
    public class PullReplicationHandler : DatabaseRequestHandler
    {
        [RavenAction("/databases/*/admin/tasks/hub-pull-replication", "PUT", AuthorizationStatus.Operator)]
        public async Task DefineHub()
        {
            if (ResourceNameValidator.IsValidResourceName(Database.Name, ServerStore.Configuration.Core.DataDirectory.FullPath, out string errorMessage) == false)
                throw new BadRequestException(errorMessage);

            ServerStore.LicenseManager.AssertCanAddPullReplication();
            await DatabaseConfigurations((_, databaseName, blittableJson) =>
                {
                    var pullReplication = JsonDeserializationClient.PullReplicationDefinition(blittableJson);
                    pullReplication.Validate(ServerStore.Server.Certificate?.Certificate != null);
                    var updatePullReplication = new UpdatePullReplicationAsHubCommand(databaseName)
                    {
                        Definition = pullReplication
                    };
                    return ServerStore.SendToLeaderAsync(updatePullReplication);
                }, "update-hub-pull-replication",
                fillJson: (json, _, index) =>
                {
                    json[nameof(OngoingTask.TaskId)] = index;
                }, statusCode: HttpStatusCode.Created);
        }

        [RavenAction("/databases/*/admin/tasks/sink-pull-replication", "POST", AuthorizationStatus.Operator)]
        public async Task UpdatePullReplicationOnSinkNode()
        {
            if (ResourceNameValidator.IsValidResourceName(Database.Name, ServerStore.Configuration.Core.DataDirectory.FullPath, out string errorMessage) == false)
                throw new BadRequestException(errorMessage);

            using (ServerStore.ContextPool.AllocateOperationContext(out TransactionOperationContext context))
            {
                PullReplicationAsSink pullReplication = null;
                await DatabaseConfigurations((_, databaseName, blittableJson) => ServerStore.UpdatePullReplicationAsSink(databaseName, blittableJson, out pullReplication), "update-sink-pull-replication",
                    fillJson: (json, _, index) =>
                    {
                        using (context.OpenReadTransaction())
                        {
                            var databaseRecord = ServerStore.Cluster.ReadDatabase(context, Database.Name);
                            json[nameof(OngoingTask.ResponsibleNode)] = Database.WhoseTaskIsIt(databaseRecord.Topology, pullReplication, null);
                        }

                        json[nameof(ModifyOngoingTaskResult.TaskId)] = pullReplication.TaskId == 0 ? index : pullReplication.TaskId;
                    }, statusCode: HttpStatusCode.Created);
            }
        }

        [RavenAction("/databases/*/admin/pull-replication/generate-hub-zip", "POST", AuthorizationStatus.Operator)]
        public async Task GeneratePullReplicationZip()
        {
            ServerStore.LicenseManager.AssertCanAddPullReplication();

            var name = GetStringQueryString("name");
            var mentor = GetStringQueryString("mentor", required: false);
            var delay = GetTimeSpanQueryString("delay", required: false);

            var definition = new PullReplicationDefinition(name, delay ?? default, mentor);
            var zipped = new ZippedPullReplication
            {
                Name = definition.Name
            };

            if (ServerStore.Server.Certificate?.Certificate != null)
            {
                var validYears = GetIntValueQueryString("validYears", required: false) ?? 0; // 0 yr. will set the expiration to 3 months

                var log = new StringBuilder();
                var commonNameValue = "PullReplicationAutogeneratedCertificate";
                CertificateUtils.CreateCertificateAuthorityCertificate(commonNameValue + " CA", out var ca, out var caSubjectName, log);
                CertificateUtils.CreateSelfSignedCertificateBasedOnPrivateKey(commonNameValue, caSubjectName, ca, false, false, validYears, out var certBytes, log);
                var certificateWithPrivateKey = new X509Certificate2(certBytes, (string)null, X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.Exportable);
                certificateWithPrivateKey.Verify();

                definition.Certificates[certificateWithPrivateKey.Thumbprint] = Convert.ToBase64String(certificateWithPrivateKey.Export(X509ContentType.Cert));

                zipped.Certificate = Convert.ToBase64String(certificateWithPrivateKey.Export(X509ContentType.Pfx));
            }

            var updatePullReplication = new UpdatePullReplicationAsHubCommand(Database.Name)
            {
                Definition = definition
            };
            await ServerStore.SendToLeaderAsync(updatePullReplication);

            HttpContext.Response.Headers["Content-Disposition"] = "attachment; filename=PullReplication.zip";
            HttpContext.Response.ContentType = "application/octet-stream";

            using (var zip = new ZipArchive(ResponseBodyStream(), ZipArchiveMode.Create))
            using (var ctx = JsonOperationContext.ShortTermSingleUse())
            {
                var pullReplicationEntry = zip.CreateEntry(ZippedEntryName);
                using (var zipStream = pullReplicationEntry.Open())
                {
                    ctx.Write(zipStream, ctx.ReadObject(zipped.ToJson(Database), "zip-pull-replication"));
                }
            }
        }

        [RavenAction("/databases/*/admin/pull-replication/unpack-sink-zip", "POST", AuthorizationStatus.Operator)]
        public async Task UnpackPullReplicationZip()
        {
            ZippedPullReplication pullReplicationInfo;
            using (ServerStore.ContextPool.AllocateOperationContext(out JsonOperationContext context))
            using (var zip = new ZipArchive(RequestBodyStream(), ZipArchiveMode.Read))
            {
                var entry = zip.GetEntry(ZippedEntryName);
                if (entry == null)
                    throw new InvalidOperationException($"The zip doesn't contain {ZippedEntryName} file.");

                using (var zippedPullReplication = context.ReadForMemory(entry.Open(), "read-zipped-pull-replication"))
                {
                    pullReplicationInfo = JsonDeserializationServer.ZippedPullReplication(zippedPullReplication);
                }
            }

            var connectionStringCommand = new PutRavenConnectionStringCommand(pullReplicationInfo.ConnectionString, Database.Name);
            await ServerStore.SendToLeaderAsync(connectionStringCommand);

            var sink = new PullReplicationAsSink(pullReplicationInfo.ConnectionString.Database, pullReplicationInfo.ConnectionString.Name, pullReplicationInfo.Name)
            {
                Name = pullReplicationInfo.ConnectionString.Name,
                CertificateWithPrivateKey = pullReplicationInfo.Certificate
            };
            var replicationAsSinkCommand = new UpdatePullReplicationAsSinkCommand(Database.Name)
            {
                PullReplicationAsSink = sink
            };

            await ServerStore.SendToLeaderAsync(replicationAsSinkCommand);
        }

        private const string ZippedEntryName = "PullReplication.json";

        internal class ZippedPullReplication
        {
            public string Name;
            public string Certificate;
            public RavenConnectionString ConnectionString;

            public DynamicJsonValue ToJson(DocumentDatabase database)
            {
                ConnectionString = new RavenConnectionString
                {
                    Database = database.Name,
                    TopologyDiscoveryUrls = database.ServerStore.GetClusterTopology().AllNodes.Select(node => node.Value).ToArray()
                };

                ConnectionString.Name = $"Pull Replication '{Name}' from database '{database.Name}' on {string.Join(", ", ConnectionString.TopologyDiscoveryUrls)}";

                return new DynamicJsonValue
                {
                    [nameof(Name)] = Name,
                    [nameof(Certificate)] = Certificate,
                    [nameof(ConnectionString)] = ConnectionString.ToJson()
                };
            }
        }

    }
}

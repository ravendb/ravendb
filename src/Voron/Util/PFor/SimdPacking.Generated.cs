using System.Runtime.Intrinsics;
using Voron.Util.PFor;

//*************
// Generated using:
//    python.exe .\simdfor.py | clang-format --style Microsoft > .\Simd.Generated.cs
//*************

namespace Voron.Util.Simd;

unsafe partial struct SimdPacking<TTransform> where TTransform : struct, ISimdTransform
{

  public
    static Vector256<uint> iunpackFOR0(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        var outputVec = (Vector256<uint> *)output;
        for (int i = 0; i < 8; ++i)
        {
            *output++ = initOffset;
            *output++ = initOffset;
            *output++ = initOffset;
            *output++ = initOffset;
        }

        return initOffset;
    }

  public
    static void ipackFOR0(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        // nothing to do here
    }

  public
    static void ipackFOR1(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 1); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 1));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 3); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 3));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 5); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 5));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 7); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 9); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 9));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 11); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 11));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 13); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 13));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 15); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 15));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 17); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 17));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 19); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 19));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 21); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 23); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 23));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 25); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 25));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 27); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 27));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 29); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 29));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 31); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 31));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR2(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR3(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 3); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 3));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 9); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 9));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 15); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 15));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 21); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 27); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 27));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 3 - 1);   // OutReg = _mm_srli_epi32(InReg, 3 - 1)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 1); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 1));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 7); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 13); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 13));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 19); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 19));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 25); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 25));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 31); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 31));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 3 - 2);   // OutReg = _mm_srli_epi32(InReg, 3 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 5); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 5));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 11); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 11));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 17); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 17));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 23); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 23));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 29); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 29));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR4(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR5(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 5); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 5));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 15); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 15));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 25); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 25));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 5 - 3);   // OutReg = _mm_srli_epi32(InReg, 5 - 3)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 3); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 3));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 13); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 13));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 23); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 23));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 5 - 1);   // OutReg = _mm_srli_epi32(InReg, 5 - 1)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 1); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 1));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 11); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 11));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 21); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 31); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 31));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 5 - 4);   // OutReg = _mm_srli_epi32(InReg, 5 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 9); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 9));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 19); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 19));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 29); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 29));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 5 - 2);   // OutReg = _mm_srli_epi32(InReg, 5 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 7); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 17); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 17));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 27); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 27));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR6(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 6 - 4);   // OutReg = _mm_srli_epi32(InReg, 6 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 6 - 2);   // OutReg = _mm_srli_epi32(InReg, 6 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 6 - 4);   // OutReg = _mm_srli_epi32(InReg, 6 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 6 - 2);   // OutReg = _mm_srli_epi32(InReg, 6 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR7(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 7); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 21); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 7 - 3);   // OutReg = _mm_srli_epi32(InReg, 7 - 3)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 3); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 3));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 17); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 17));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 31); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 31));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 7 - 6);   // OutReg = _mm_srli_epi32(InReg, 7 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 13); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 13));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 27); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 27));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 7 - 2);   // OutReg = _mm_srli_epi32(InReg, 7 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 9); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 9));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 23); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 23));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 7 - 5);   // OutReg = _mm_srli_epi32(InReg, 7 - 5)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 5); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 5));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 19); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 19));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 7 - 1);   // OutReg = _mm_srli_epi32(InReg, 7 - 1)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 1); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 1));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 15); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 15));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 29); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 29));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 7 - 4);   // OutReg = _mm_srli_epi32(InReg, 7 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 11); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 11));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 25); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 25));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR8(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR9(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 9); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 9));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 27); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 27));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 9 - 4);   // OutReg = _mm_srli_epi32(InReg, 9 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 13); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 13));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 31); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 31));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 9 - 8);   // OutReg = _mm_srli_epi32(InReg, 9 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 17); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 17));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 9 - 3);   // OutReg = _mm_srli_epi32(InReg, 9 - 3)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 3); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 3));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 21); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 9 - 7);   // OutReg = _mm_srli_epi32(InReg, 9 - 7)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 7); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 25); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 25));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 9 - 2);   // OutReg = _mm_srli_epi32(InReg, 9 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 11); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 11));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 29); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 29));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 9 - 6);   // OutReg = _mm_srli_epi32(InReg, 9 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 15); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 15));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 9 - 1);   // OutReg = _mm_srli_epi32(InReg, 9 - 1)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 1); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 1));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 19); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 19));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 9 - 5);   // OutReg = _mm_srli_epi32(InReg, 9 - 5)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 5); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 5));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 23); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 23));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR10(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 10 - 8);  // OutReg = _mm_srli_epi32(InReg, 10 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 10 - 6);  // OutReg = _mm_srli_epi32(InReg, 10 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 10 - 4);  // OutReg = _mm_srli_epi32(InReg, 10 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 10 - 2);  // OutReg = _mm_srli_epi32(InReg, 10 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 10 - 8);  // OutReg = _mm_srli_epi32(InReg, 10 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 10 - 6);  // OutReg = _mm_srli_epi32(InReg, 10 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 10 - 4);  // OutReg = _mm_srli_epi32(InReg, 10 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 10 - 2);  // OutReg = _mm_srli_epi32(InReg, 10 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR11(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 11); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 11));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 11 - 1);  // OutReg = _mm_srli_epi32(InReg, 11 - 1)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 1); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 1));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 23); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 23));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 11 - 2);  // OutReg = _mm_srli_epi32(InReg, 11 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 13); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 13));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 11 - 3);  // OutReg = _mm_srli_epi32(InReg, 11 - 3)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 3); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 3));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 25); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 25));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 11 - 4);  // OutReg = _mm_srli_epi32(InReg, 11 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 15); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 15));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 11 - 5);  // OutReg = _mm_srli_epi32(InReg, 11 - 5)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 5); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 5));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 27); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 27));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 11 - 6);  // OutReg = _mm_srli_epi32(InReg, 11 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 17); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 17));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 11 - 7);  // OutReg = _mm_srli_epi32(InReg, 11 - 7)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 7); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 29); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 29));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 11 - 8);  // OutReg = _mm_srli_epi32(InReg, 11 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 19); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 19));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 11 - 9);  // OutReg = _mm_srli_epi32(InReg, 11 - 9)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 9); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 9));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 31); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 31));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 11 - 10); // OutReg = _mm_srli_epi32(InReg, 11 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 21); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR12(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 12 - 4);  // OutReg = _mm_srli_epi32(InReg, 12 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 12 - 8);  // OutReg = _mm_srli_epi32(InReg, 12 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 12 - 4);  // OutReg = _mm_srli_epi32(InReg, 12 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 12 - 8);  // OutReg = _mm_srli_epi32(InReg, 12 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 12 - 4);  // OutReg = _mm_srli_epi32(InReg, 12 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 12 - 8);  // OutReg = _mm_srli_epi32(InReg, 12 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 12 - 4);  // OutReg = _mm_srli_epi32(InReg, 12 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 12 - 8);  // OutReg = _mm_srli_epi32(InReg, 12 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR13(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 13); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 13));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 13 - 7);  // OutReg = _mm_srli_epi32(InReg, 13 - 7)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 7); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 13 - 1);  // OutReg = _mm_srli_epi32(InReg, 13 - 1)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 1); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 1));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 27); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 27));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 13 - 8);  // OutReg = _mm_srli_epi32(InReg, 13 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 21); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 13 - 2);  // OutReg = _mm_srli_epi32(InReg, 13 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 15); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 15));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 13 - 9);  // OutReg = _mm_srli_epi32(InReg, 13 - 9)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 9); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 9));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 13 - 3);  // OutReg = _mm_srli_epi32(InReg, 13 - 3)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 3); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 3));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 29); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 29));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 13 - 10); // OutReg = _mm_srli_epi32(InReg, 13 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 23); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 23));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 13 - 4);  // OutReg = _mm_srli_epi32(InReg, 13 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 17); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 17));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 13 - 11); // OutReg = _mm_srli_epi32(InReg, 13 - 11)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 11); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 11));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 13 - 5);  // OutReg = _mm_srli_epi32(InReg, 13 - 5)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 5); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 5));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 31); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 31));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 13 - 12); // OutReg = _mm_srli_epi32(InReg, 13 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 25); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 25));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 13 - 6);  // OutReg = _mm_srli_epi32(InReg, 13 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 19); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 19));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR14(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 14 - 10); // OutReg = _mm_srli_epi32(InReg, 14 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 14 - 6);  // OutReg = _mm_srli_epi32(InReg, 14 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 14 - 2);  // OutReg = _mm_srli_epi32(InReg, 14 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 14 - 12); // OutReg = _mm_srli_epi32(InReg, 14 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 14 - 8);  // OutReg = _mm_srli_epi32(InReg, 14 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 14 - 4);  // OutReg = _mm_srli_epi32(InReg, 14 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 14 - 10); // OutReg = _mm_srli_epi32(InReg, 14 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 14 - 6);  // OutReg = _mm_srli_epi32(InReg, 14 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 14 - 2);  // OutReg = _mm_srli_epi32(InReg, 14 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 14 - 12); // OutReg = _mm_srli_epi32(InReg, 14 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 14 - 8);  // OutReg = _mm_srli_epi32(InReg, 14 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 14 - 4);  // OutReg = _mm_srli_epi32(InReg, 14 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR15(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 15); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 15));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 15 - 13); // OutReg = _mm_srli_epi32(InReg, 15 - 13)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 13); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 13));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 15 - 11); // OutReg = _mm_srli_epi32(InReg, 15 - 11)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 11); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 11));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 15 - 9);  // OutReg = _mm_srli_epi32(InReg, 15 - 9)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 9); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 9));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 15 - 7);  // OutReg = _mm_srli_epi32(InReg, 15 - 7)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 7); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 15 - 5);  // OutReg = _mm_srli_epi32(InReg, 15 - 5)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 5); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 5));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 15 - 3);  // OutReg = _mm_srli_epi32(InReg, 15 - 3)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 3); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 3));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 15 - 1);  // OutReg = _mm_srli_epi32(InReg, 15 - 1)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 1); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 1));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 31); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 31));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 15 - 14); // OutReg = _mm_srli_epi32(InReg, 15 - 14)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 29); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 29));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 15 - 12); // OutReg = _mm_srli_epi32(InReg, 15 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 27); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 27));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 15 - 10); // OutReg = _mm_srli_epi32(InReg, 15 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 25); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 25));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 15 - 8);  // OutReg = _mm_srli_epi32(InReg, 15 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 23); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 23));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 15 - 6);  // OutReg = _mm_srli_epi32(InReg, 15 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 21); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 15 - 4);  // OutReg = _mm_srli_epi32(InReg, 15 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 19); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 19));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 15 - 2);  // OutReg = _mm_srli_epi32(InReg, 15 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 17); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 17));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR16(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR17(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 17); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 17));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 17 - 2);  // OutReg = _mm_srli_epi32(InReg, 17 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 19); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 19));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 17 - 4);  // OutReg = _mm_srli_epi32(InReg, 17 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 21); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 17 - 6);  // OutReg = _mm_srli_epi32(InReg, 17 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 23); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 23));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 17 - 8);  // OutReg = _mm_srli_epi32(InReg, 17 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 25); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 25));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 17 - 10); // OutReg = _mm_srli_epi32(InReg, 17 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 27); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 27));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 17 - 12); // OutReg = _mm_srli_epi32(InReg, 17 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 29); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 29));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 17 - 14); // OutReg = _mm_srli_epi32(InReg, 17 - 14)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 31); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 31));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 17 - 16); // OutReg = _mm_srli_epi32(InReg, 17 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 17 - 1);  // OutReg = _mm_srli_epi32(InReg, 17 - 1)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 1); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 1));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 17 - 3);  // OutReg = _mm_srli_epi32(InReg, 17 - 3)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 3); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 3));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 17 - 5);  // OutReg = _mm_srli_epi32(InReg, 17 - 5)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 5); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 5));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 17 - 7);  // OutReg = _mm_srli_epi32(InReg, 17 - 7)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 7); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 17 - 9);  // OutReg = _mm_srli_epi32(InReg, 17 - 9)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 9); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 9));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 17 - 11); // OutReg = _mm_srli_epi32(InReg, 17 - 11)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 11); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 11));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 17 - 13); // OutReg = _mm_srli_epi32(InReg, 17 - 13)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 13); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 13));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 17 - 15); // OutReg = _mm_srli_epi32(InReg, 17 - 15)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 15); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 15));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR18(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 18 - 4);  // OutReg = _mm_srli_epi32(InReg, 18 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 18 - 8);  // OutReg = _mm_srli_epi32(InReg, 18 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 18 - 12); // OutReg = _mm_srli_epi32(InReg, 18 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 18 - 16); // OutReg = _mm_srli_epi32(InReg, 18 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 18 - 2);  // OutReg = _mm_srli_epi32(InReg, 18 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 18 - 6);  // OutReg = _mm_srli_epi32(InReg, 18 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 18 - 10); // OutReg = _mm_srli_epi32(InReg, 18 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 18 - 14); // OutReg = _mm_srli_epi32(InReg, 18 - 14)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 18 - 4);  // OutReg = _mm_srli_epi32(InReg, 18 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 18 - 8);  // OutReg = _mm_srli_epi32(InReg, 18 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 18 - 12); // OutReg = _mm_srli_epi32(InReg, 18 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 18 - 16); // OutReg = _mm_srli_epi32(InReg, 18 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 18 - 2);  // OutReg = _mm_srli_epi32(InReg, 18 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 18 - 6);  // OutReg = _mm_srli_epi32(InReg, 18 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 18 - 10); // OutReg = _mm_srli_epi32(InReg, 18 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 18 - 14); // OutReg = _mm_srli_epi32(InReg, 18 - 14)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR19(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 19); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 19));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 6);  // OutReg = _mm_srli_epi32(InReg, 19 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 25); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 25));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 12); // OutReg = _mm_srli_epi32(InReg, 19 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 31); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 31));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 18); // OutReg = _mm_srli_epi32(InReg, 19 - 18)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 5);  // OutReg = _mm_srli_epi32(InReg, 19 - 5)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 5); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 5));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 11); // OutReg = _mm_srli_epi32(InReg, 19 - 11)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 11); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 11));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 17); // OutReg = _mm_srli_epi32(InReg, 19 - 17)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 17); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 17));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 4);  // OutReg = _mm_srli_epi32(InReg, 19 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 23); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 23));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 10); // OutReg = _mm_srli_epi32(InReg, 19 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 29); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 29));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 16); // OutReg = _mm_srli_epi32(InReg, 19 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 3);  // OutReg = _mm_srli_epi32(InReg, 19 - 3)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 3); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 3));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 9);  // OutReg = _mm_srli_epi32(InReg, 19 - 9)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 9); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 9));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 15); // OutReg = _mm_srli_epi32(InReg, 19 - 15)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 15); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 15));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 2);  // OutReg = _mm_srli_epi32(InReg, 19 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 21); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 8);  // OutReg = _mm_srli_epi32(InReg, 19 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 27); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 27));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 14); // OutReg = _mm_srli_epi32(InReg, 19 - 14)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 1);  // OutReg = _mm_srli_epi32(InReg, 19 - 1)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 1); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 1));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 7);  // OutReg = _mm_srli_epi32(InReg, 19 - 7)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 7); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 19 - 13); // OutReg = _mm_srli_epi32(InReg, 19 - 13)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 13); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 13));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR20(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 20 - 8);  // OutReg = _mm_srli_epi32(InReg, 20 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 20 - 16); // OutReg = _mm_srli_epi32(InReg, 20 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 20 - 4);  // OutReg = _mm_srli_epi32(InReg, 20 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 20 - 12); // OutReg = _mm_srli_epi32(InReg, 20 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 20 - 8);  // OutReg = _mm_srli_epi32(InReg, 20 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 20 - 16); // OutReg = _mm_srli_epi32(InReg, 20 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 20 - 4);  // OutReg = _mm_srli_epi32(InReg, 20 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 20 - 12); // OutReg = _mm_srli_epi32(InReg, 20 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 20 - 8);  // OutReg = _mm_srli_epi32(InReg, 20 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 20 - 16); // OutReg = _mm_srli_epi32(InReg, 20 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 20 - 4);  // OutReg = _mm_srli_epi32(InReg, 20 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 20 - 12); // OutReg = _mm_srli_epi32(InReg, 20 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 20 - 8);  // OutReg = _mm_srli_epi32(InReg, 20 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 20 - 16); // OutReg = _mm_srli_epi32(InReg, 20 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 20 - 4);  // OutReg = _mm_srli_epi32(InReg, 20 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 20 - 12); // OutReg = _mm_srli_epi32(InReg, 20 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR21(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 21); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 10); // OutReg = _mm_srli_epi32(InReg, 21 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        ++input;                                  // ++in;
        currIn = *input;                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 31); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 31));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 20); // OutReg = _mm_srli_epi32(InReg, 21 - 20)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 9);  // OutReg = _mm_srli_epi32(InReg, 21 - 9)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 9); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 9));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 19); // OutReg = _mm_srli_epi32(InReg, 21 - 19)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 19); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 19));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 8);  // OutReg = _mm_srli_epi32(InReg, 21 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 29); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 29));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 18); // OutReg = _mm_srli_epi32(InReg, 21 - 18)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 7);  // OutReg = _mm_srli_epi32(InReg, 21 - 7)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 7); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 17); // OutReg = _mm_srli_epi32(InReg, 21 - 17)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 17); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 17));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 6);  // OutReg = _mm_srli_epi32(InReg, 21 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 27); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 27));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 16); // OutReg = _mm_srli_epi32(InReg, 21 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 5);  // OutReg = _mm_srli_epi32(InReg, 21 - 5)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 5); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 5));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 15); // OutReg = _mm_srli_epi32(InReg, 21 - 15)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 15); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 15));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 4);  // OutReg = _mm_srli_epi32(InReg, 21 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 25); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 25));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 14); // OutReg = _mm_srli_epi32(InReg, 21 - 14)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 3);  // OutReg = _mm_srli_epi32(InReg, 21 - 3)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 3); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 3));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 13); // OutReg = _mm_srli_epi32(InReg, 21 - 13)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 13); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 13));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 2);  // OutReg = _mm_srli_epi32(InReg, 21 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 23); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 23));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 12); // OutReg = _mm_srli_epi32(InReg, 21 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 1);  // OutReg = _mm_srli_epi32(InReg, 21 - 1)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 1); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 1));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 21 - 11); // OutReg = _mm_srli_epi32(InReg, 21 - 11)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 11); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 11));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR22(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 12); // OutReg = _mm_srli_epi32(InReg, 22 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 2);  // OutReg = _mm_srli_epi32(InReg, 22 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 14); // OutReg = _mm_srli_epi32(InReg, 22 - 14)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 4);  // OutReg = _mm_srli_epi32(InReg, 22 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 16); // OutReg = _mm_srli_epi32(InReg, 22 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 6);  // OutReg = _mm_srli_epi32(InReg, 22 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 18); // OutReg = _mm_srli_epi32(InReg, 22 - 18)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 8);  // OutReg = _mm_srli_epi32(InReg, 22 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 20); // OutReg = _mm_srli_epi32(InReg, 22 - 20)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 10); // OutReg = _mm_srli_epi32(InReg, 22 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 12); // OutReg = _mm_srli_epi32(InReg, 22 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 2);  // OutReg = _mm_srli_epi32(InReg, 22 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 14); // OutReg = _mm_srli_epi32(InReg, 22 - 14)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 4);  // OutReg = _mm_srli_epi32(InReg, 22 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 16); // OutReg = _mm_srli_epi32(InReg, 22 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 6);  // OutReg = _mm_srli_epi32(InReg, 22 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 18); // OutReg = _mm_srli_epi32(InReg, 22 - 18)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 8);  // OutReg = _mm_srli_epi32(InReg, 22 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 20); // OutReg = _mm_srli_epi32(InReg, 22 - 20)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 22 - 10); // OutReg = _mm_srli_epi32(InReg, 22 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        *output = outReg;                         // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR23(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 23); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 23));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 14); // OutReg = _mm_srli_epi32(InReg, 23 - 14)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 5);  // OutReg = _mm_srli_epi32(InReg, 23 - 5)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 5); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 5));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 19); // OutReg = _mm_srli_epi32(InReg, 23 - 19)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 19); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 19));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 10); // OutReg = _mm_srli_epi32(InReg, 23 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 1);  // OutReg = _mm_srli_epi32(InReg, 23 - 1)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 1); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 1));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 15); // OutReg = _mm_srli_epi32(InReg, 23 - 15)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 15); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 15));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 6);  // OutReg = _mm_srli_epi32(InReg, 23 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 29); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 29));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 20); // OutReg = _mm_srli_epi32(InReg, 23 - 20)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 11); // OutReg = _mm_srli_epi32(InReg, 23 - 11)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 11); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 11));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 2);  // OutReg = _mm_srli_epi32(InReg, 23 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 25); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 25));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 16); // OutReg = _mm_srli_epi32(InReg, 23 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 7);  // OutReg = _mm_srli_epi32(InReg, 23 - 7)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 7); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 21); // OutReg = _mm_srli_epi32(InReg, 23 - 21)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 21); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 12); // OutReg = _mm_srli_epi32(InReg, 23 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 3);  // OutReg = _mm_srli_epi32(InReg, 23 - 3)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 3); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 3));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 17); // OutReg = _mm_srli_epi32(InReg, 23 - 17)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 17); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 17));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 8);  // OutReg = _mm_srli_epi32(InReg, 23 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 31); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 31));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 22); // OutReg = _mm_srli_epi32(InReg, 23 - 22)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 13); // OutReg = _mm_srli_epi32(InReg, 23 - 13)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 13); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 13));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 4);  // OutReg = _mm_srli_epi32(InReg, 23 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 27); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 27));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 18); // OutReg = _mm_srli_epi32(InReg, 23 - 18)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 23 - 9);  // OutReg = _mm_srli_epi32(InReg, 23 - 9)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 9); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 9));
        *output = outReg;                        // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR24(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 24 - 16); // OutReg = _mm_srli_epi32(InReg, 24 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 24 - 8);  // OutReg = _mm_srli_epi32(InReg, 24 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 24 - 16); // OutReg = _mm_srli_epi32(InReg, 24 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 24 - 8);  // OutReg = _mm_srli_epi32(InReg, 24 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 24 - 16); // OutReg = _mm_srli_epi32(InReg, 24 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 24 - 8);  // OutReg = _mm_srli_epi32(InReg, 24 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 24 - 16); // OutReg = _mm_srli_epi32(InReg, 24 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 24 - 8);  // OutReg = _mm_srli_epi32(InReg, 24 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 24 - 16); // OutReg = _mm_srli_epi32(InReg, 24 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 24 - 8);  // OutReg = _mm_srli_epi32(InReg, 24 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 24 - 16); // OutReg = _mm_srli_epi32(InReg, 24 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 24 - 8);  // OutReg = _mm_srli_epi32(InReg, 24 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 24 - 16); // OutReg = _mm_srli_epi32(InReg, 24 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 24 - 8);  // OutReg = _mm_srli_epi32(InReg, 24 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 24 - 16); // OutReg = _mm_srli_epi32(InReg, 24 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 24 - 8);  // OutReg = _mm_srli_epi32(InReg, 24 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR25(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 25); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 25));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 18); // OutReg = _mm_srli_epi32(InReg, 25 - 18)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 11); // OutReg = _mm_srli_epi32(InReg, 25 - 11)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 11); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 11));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 4);  // OutReg = _mm_srli_epi32(InReg, 25 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 29); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 29));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 22); // OutReg = _mm_srli_epi32(InReg, 25 - 22)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 15); // OutReg = _mm_srli_epi32(InReg, 25 - 15)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 15); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 15));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 8);  // OutReg = _mm_srli_epi32(InReg, 25 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 1);  // OutReg = _mm_srli_epi32(InReg, 25 - 1)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 1); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 1));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 19); // OutReg = _mm_srli_epi32(InReg, 25 - 19)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 19); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 19));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 12); // OutReg = _mm_srli_epi32(InReg, 25 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 5);  // OutReg = _mm_srli_epi32(InReg, 25 - 5)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 5); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 5));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 23); // OutReg = _mm_srli_epi32(InReg, 25 - 23)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 23); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 23));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 16); // OutReg = _mm_srli_epi32(InReg, 25 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 9);  // OutReg = _mm_srli_epi32(InReg, 25 - 9)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 9); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 9));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 2);  // OutReg = _mm_srli_epi32(InReg, 25 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 27); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 27));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 20); // OutReg = _mm_srli_epi32(InReg, 25 - 20)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 13); // OutReg = _mm_srli_epi32(InReg, 25 - 13)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 13); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 13));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 6);  // OutReg = _mm_srli_epi32(InReg, 25 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 31); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 31));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 24); // OutReg = _mm_srli_epi32(InReg, 25 - 24)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 17); // OutReg = _mm_srli_epi32(InReg, 25 - 17)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 17); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 17));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 10); // OutReg = _mm_srli_epi32(InReg, 25 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 3);  // OutReg = _mm_srli_epi32(InReg, 25 - 3)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 3); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 3));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 21); // OutReg = _mm_srli_epi32(InReg, 25 - 21)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 21); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 14); // OutReg = _mm_srli_epi32(InReg, 25 - 14)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 25 - 7);  // OutReg = _mm_srli_epi32(InReg, 25 - 7)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 7); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));
        *output = outReg;                        // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR26(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 20); // OutReg = _mm_srli_epi32(InReg, 26 - 20)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 14); // OutReg = _mm_srli_epi32(InReg, 26 - 14)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 8);  // OutReg = _mm_srli_epi32(InReg, 26 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 2);  // OutReg = _mm_srli_epi32(InReg, 26 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 22); // OutReg = _mm_srli_epi32(InReg, 26 - 22)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 16); // OutReg = _mm_srli_epi32(InReg, 26 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 10); // OutReg = _mm_srli_epi32(InReg, 26 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 4);  // OutReg = _mm_srli_epi32(InReg, 26 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 24); // OutReg = _mm_srli_epi32(InReg, 26 - 24)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 18); // OutReg = _mm_srli_epi32(InReg, 26 - 18)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 12); // OutReg = _mm_srli_epi32(InReg, 26 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 6);  // OutReg = _mm_srli_epi32(InReg, 26 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 20); // OutReg = _mm_srli_epi32(InReg, 26 - 20)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 14); // OutReg = _mm_srli_epi32(InReg, 26 - 14)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 8);  // OutReg = _mm_srli_epi32(InReg, 26 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 2);  // OutReg = _mm_srli_epi32(InReg, 26 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 22); // OutReg = _mm_srli_epi32(InReg, 26 - 22)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 16); // OutReg = _mm_srli_epi32(InReg, 26 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 10); // OutReg = _mm_srli_epi32(InReg, 26 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 4);  // OutReg = _mm_srli_epi32(InReg, 26 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 24); // OutReg = _mm_srli_epi32(InReg, 26 - 24)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 18); // OutReg = _mm_srli_epi32(InReg, 26 - 18)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 12); // OutReg = _mm_srli_epi32(InReg, 26 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 26 - 6);  // OutReg = _mm_srli_epi32(InReg, 26 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        *output = outReg;                        // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR27(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 27); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 27));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 22); // OutReg = _mm_srli_epi32(InReg, 27 - 22)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 17); // OutReg = _mm_srli_epi32(InReg, 27 - 17)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 17); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 17));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 12); // OutReg = _mm_srli_epi32(InReg, 27 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 7);  // OutReg = _mm_srli_epi32(InReg, 27 - 7)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 7); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 2);  // OutReg = _mm_srli_epi32(InReg, 27 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 29); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 29));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 24); // OutReg = _mm_srli_epi32(InReg, 27 - 24)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 19); // OutReg = _mm_srli_epi32(InReg, 27 - 19)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 19); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 19));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 14); // OutReg = _mm_srli_epi32(InReg, 27 - 14)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 9);  // OutReg = _mm_srli_epi32(InReg, 27 - 9)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 9); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 9));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 4);  // OutReg = _mm_srli_epi32(InReg, 27 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 31); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 31));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 26); // OutReg = _mm_srli_epi32(InReg, 27 - 26)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 21); // OutReg = _mm_srli_epi32(InReg, 27 - 21)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 21); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 16); // OutReg = _mm_srli_epi32(InReg, 27 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 11); // OutReg = _mm_srli_epi32(InReg, 27 - 11)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 11); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 11));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 6);  // OutReg = _mm_srli_epi32(InReg, 27 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 1);  // OutReg = _mm_srli_epi32(InReg, 27 - 1)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 1); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 1));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 23); // OutReg = _mm_srli_epi32(InReg, 27 - 23)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 23); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 23));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 18); // OutReg = _mm_srli_epi32(InReg, 27 - 18)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 13); // OutReg = _mm_srli_epi32(InReg, 27 - 13)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 13); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 13));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 8);  // OutReg = _mm_srli_epi32(InReg, 27 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 3);  // OutReg = _mm_srli_epi32(InReg, 27 - 3)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 3); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 3));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 25); // OutReg = _mm_srli_epi32(InReg, 27 - 25)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 25); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 25));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 20); // OutReg = _mm_srli_epi32(InReg, 27 - 20)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 15); // OutReg = _mm_srli_epi32(InReg, 27 - 15)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 15); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 15));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 10); // OutReg = _mm_srli_epi32(InReg, 27 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 27 - 5);  // OutReg = _mm_srli_epi32(InReg, 27 - 5)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 5); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 5));
        *output = outReg;                        // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR28(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 24); // OutReg = _mm_srli_epi32(InReg, 28 - 24)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 20); // OutReg = _mm_srli_epi32(InReg, 28 - 20)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 16); // OutReg = _mm_srli_epi32(InReg, 28 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 12); // OutReg = _mm_srli_epi32(InReg, 28 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 8);  // OutReg = _mm_srli_epi32(InReg, 28 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 4);  // OutReg = _mm_srli_epi32(InReg, 28 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 24); // OutReg = _mm_srli_epi32(InReg, 28 - 24)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 20); // OutReg = _mm_srli_epi32(InReg, 28 - 20)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 16); // OutReg = _mm_srli_epi32(InReg, 28 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 12); // OutReg = _mm_srli_epi32(InReg, 28 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 8);  // OutReg = _mm_srli_epi32(InReg, 28 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 4);  // OutReg = _mm_srli_epi32(InReg, 28 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 24); // OutReg = _mm_srli_epi32(InReg, 28 - 24)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 20); // OutReg = _mm_srli_epi32(InReg, 28 - 20)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 16); // OutReg = _mm_srli_epi32(InReg, 28 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 12); // OutReg = _mm_srli_epi32(InReg, 28 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 8);  // OutReg = _mm_srli_epi32(InReg, 28 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 4);  // OutReg = _mm_srli_epi32(InReg, 28 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 24); // OutReg = _mm_srli_epi32(InReg, 28 - 24)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 20); // OutReg = _mm_srli_epi32(InReg, 28 - 20)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 16); // OutReg = _mm_srli_epi32(InReg, 28 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 12); // OutReg = _mm_srli_epi32(InReg, 28 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 8);  // OutReg = _mm_srli_epi32(InReg, 28 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 28 - 4);  // OutReg = _mm_srli_epi32(InReg, 28 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        *output = outReg;                        // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR29(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 29); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 29));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 26); // OutReg = _mm_srli_epi32(InReg, 29 - 26)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 23); // OutReg = _mm_srli_epi32(InReg, 29 - 23)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 23); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 23));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 20); // OutReg = _mm_srli_epi32(InReg, 29 - 20)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 17); // OutReg = _mm_srli_epi32(InReg, 29 - 17)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 17); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 17));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 14); // OutReg = _mm_srli_epi32(InReg, 29 - 14)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 11); // OutReg = _mm_srli_epi32(InReg, 29 - 11)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 11); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 11));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 8);  // OutReg = _mm_srli_epi32(InReg, 29 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 5);  // OutReg = _mm_srli_epi32(InReg, 29 - 5)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 5); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 5));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 2);  // OutReg = _mm_srli_epi32(InReg, 29 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 31); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 31));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 28); // OutReg = _mm_srli_epi32(InReg, 29 - 28)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 25); // OutReg = _mm_srli_epi32(InReg, 29 - 25)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 25); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 25));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 22); // OutReg = _mm_srli_epi32(InReg, 29 - 22)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 19); // OutReg = _mm_srli_epi32(InReg, 29 - 19)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 19); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 19));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 16); // OutReg = _mm_srli_epi32(InReg, 29 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 13); // OutReg = _mm_srli_epi32(InReg, 29 - 13)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 13); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 13));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 10); // OutReg = _mm_srli_epi32(InReg, 29 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 7);  // OutReg = _mm_srli_epi32(InReg, 29 - 7)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 7); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 4);  // OutReg = _mm_srli_epi32(InReg, 29 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 1);  // OutReg = _mm_srli_epi32(InReg, 29 - 1)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 1); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 1));
        ++input;                                 // ++in;
        currIn = *input;                         // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 27); // OutReg = _mm_srli_epi32(InReg, 29 - 27)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 27); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 27));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 24); // OutReg = _mm_srli_epi32(InReg, 29 - 24)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 21); // OutReg = _mm_srli_epi32(InReg, 29 - 21)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 21); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 18); // OutReg = _mm_srli_epi32(InReg, 29 - 18)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 15); // OutReg = _mm_srli_epi32(InReg, 29 - 15)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 15); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 15));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 12); // OutReg = _mm_srli_epi32(InReg, 29 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 9);  // OutReg = _mm_srli_epi32(InReg, 29 - 9)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 9); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 9));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 6);  // OutReg = _mm_srli_epi32(InReg, 29 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 29 - 3);  // OutReg = _mm_srli_epi32(InReg, 29 - 3)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 3); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 3));
        *output = outReg;                        // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR30(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 28); // OutReg = _mm_srli_epi32(InReg, 30 - 28)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 26); // OutReg = _mm_srli_epi32(InReg, 30 - 26)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 24); // OutReg = _mm_srli_epi32(InReg, 30 - 24)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 22); // OutReg = _mm_srli_epi32(InReg, 30 - 22)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 20); // OutReg = _mm_srli_epi32(InReg, 30 - 20)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 18); // OutReg = _mm_srli_epi32(InReg, 30 - 18)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 16); // OutReg = _mm_srli_epi32(InReg, 30 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 14); // OutReg = _mm_srli_epi32(InReg, 30 - 14)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 12); // OutReg = _mm_srli_epi32(InReg, 30 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 10); // OutReg = _mm_srli_epi32(InReg, 30 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 8);  // OutReg = _mm_srli_epi32(InReg, 30 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 6);  // OutReg = _mm_srli_epi32(InReg, 30 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 4);  // OutReg = _mm_srli_epi32(InReg, 30 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 2);  // OutReg = _mm_srli_epi32(InReg, 30 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg = inReg;                                       //  OutReg = InReg;
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 28); // OutReg = _mm_srli_epi32(InReg, 30 - 28)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 26); // OutReg = _mm_srli_epi32(InReg, 30 - 26)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 24); // OutReg = _mm_srli_epi32(InReg, 30 - 24)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 22); // OutReg = _mm_srli_epi32(InReg, 30 - 22)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 20); // OutReg = _mm_srli_epi32(InReg, 30 - 20)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 18); // OutReg = _mm_srli_epi32(InReg, 30 - 18)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 16); // OutReg = _mm_srli_epi32(InReg, 30 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 14); // OutReg = _mm_srli_epi32(InReg, 30 - 14)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 12); // OutReg = _mm_srli_epi32(InReg, 30 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 10); // OutReg = _mm_srli_epi32(InReg, 30 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 8);  // OutReg = _mm_srli_epi32(InReg, 30 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 6);  // OutReg = _mm_srli_epi32(InReg, 30 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 4);  // OutReg = _mm_srli_epi32(InReg, 30 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 30 - 2);  // OutReg = _mm_srli_epi32(InReg, 30 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        *output = outReg;                        // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR31(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        
        var currIn = *input;                                      // __m128i CurrIn = _mm_load_si128(in);
        var inReg = simdTransform.Encode(currIn, ref initOffset); // __m128i InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = currIn;
        outReg = inReg;                                           //  OutReg = InReg;
        ++input;                                                  // ++in;
        currIn = *input;                                          // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset);     // InReg = Delta(CurrIn, initOffset);
                                                                  // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 31); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 31));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 30); // OutReg = _mm_srli_epi32(InReg, 31 - 30)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 30); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 30));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 29); // OutReg = _mm_srli_epi32(InReg, 31 - 29)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 29); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 29));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 28); // OutReg = _mm_srli_epi32(InReg, 31 - 28)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 28); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 28));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 27); // OutReg = _mm_srli_epi32(InReg, 31 - 27)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 27); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 27));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 26); // OutReg = _mm_srli_epi32(InReg, 31 - 26)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 26); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 26));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 25); // OutReg = _mm_srli_epi32(InReg, 31 - 25)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 25); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 25));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 24); // OutReg = _mm_srli_epi32(InReg, 31 - 24)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 24); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 24));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 23); // OutReg = _mm_srli_epi32(InReg, 31 - 23)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 23); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 23));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 22); // OutReg = _mm_srli_epi32(InReg, 31 - 22)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 22); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 22));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 21); // OutReg = _mm_srli_epi32(InReg, 31 - 21)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 21); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 21));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 20); // OutReg = _mm_srli_epi32(InReg, 31 - 20)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 20); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 20));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 19); // OutReg = _mm_srli_epi32(InReg, 31 - 19)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 19); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 19));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 18); // OutReg = _mm_srli_epi32(InReg, 31 - 18)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 18); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 18));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 17); // OutReg = _mm_srli_epi32(InReg, 31 - 17)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 17); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 17));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 16); // OutReg = _mm_srli_epi32(InReg, 31 - 16)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 16); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 16));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 15); // OutReg = _mm_srli_epi32(InReg, 31 - 15)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 15); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 15));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 14); // OutReg = _mm_srli_epi32(InReg, 31 - 14)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 14); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 14));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 13); // OutReg = _mm_srli_epi32(InReg, 31 - 13)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 13); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 13));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 12); // OutReg = _mm_srli_epi32(InReg, 31 - 12)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 12); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 12));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 11); // OutReg = _mm_srli_epi32(InReg, 31 - 11)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 11); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 11));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 10); // OutReg = _mm_srli_epi32(InReg, 31 - 10)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 10); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 10));
        *output = outReg;                         // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 9);  // OutReg = _mm_srli_epi32(InReg, 31 - 9)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 9); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 9));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 8);  // OutReg = _mm_srli_epi32(InReg, 31 - 8)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 8); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 8));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 7);  // OutReg = _mm_srli_epi32(InReg, 31 - 7)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 7); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 7));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 6);  // OutReg = _mm_srli_epi32(InReg, 31 - 6)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 6); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 6));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 5);  // OutReg = _mm_srli_epi32(InReg, 31 - 5)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 5); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 5));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 4);  // OutReg = _mm_srli_epi32(InReg, 31 - 4)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 4); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 4));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 3);  // OutReg = _mm_srli_epi32(InReg, 31 - 3)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 3); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 3));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 2);  // OutReg = _mm_srli_epi32(InReg, 31 - 2)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 2); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 2));
        *output = outReg;                        // _mm_store_si128(out, OutReg);

        ++output;                                             // ++out;
        outReg = Vector256.ShiftRightLogical(inReg, 31 - 1);  // OutReg = _mm_srli_epi32(InReg, 31 - 1)
        ++input;                                              // ++in;
        currIn = *input;                                      // CurrIn = _mm_load_si128(in);
        inReg = simdTransform.Encode(currIn, ref initOffset); // InReg = Delta(CurrIn, initOffset);
                                                              // initOffset = CurrIn;

        outReg |= Vector256.ShiftLeft(inReg, 1); // OutReg = _mm_or_si128(OutReg, _mm_slli_epi32(InReg, 1));
        *output = outReg;                        // _mm_store_si128(out, OutReg);
    }

  public
    static void ipackFOR32(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        Vector256<uint> outReg;

        var inReg = *input; // __m128i InReg = _mm_load_si128(in);
        outReg = inReg;     //  OutReg = InReg;
        *output = outReg;   // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);

        ++output;       // ++out;
        ++input;        // ++in;
        inReg = *input; // InReg = _mm_load_si128(in);

        outReg = inReg;   //  OutReg = InReg;
        *output = outReg; // _mm_store_si128(out, OutReg);
    }

  public
    static void iunpackFOR1(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 1) - 1); // _mm_set1_epi32((1U<<1)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 1);           // tmp = _mm_srli_epi32(InReg,1)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 3);           // tmp = _mm_srli_epi32(InReg,3)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 5);           // tmp = _mm_srli_epi32(InReg,5)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 7);           // tmp = _mm_srli_epi32(InReg,7)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 9);           // tmp = _mm_srli_epi32(InReg,9)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 11);          // tmp = _mm_srli_epi32(InReg,11)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 13);          // tmp = _mm_srli_epi32(InReg,13)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 15);          // tmp = _mm_srli_epi32(InReg,15)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 17);          // tmp = _mm_srli_epi32(InReg,17)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18);          // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 19);          // tmp = _mm_srli_epi32(InReg,19)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 21);          // tmp = _mm_srli_epi32(InReg,21)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22);          // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 23);          // tmp = _mm_srli_epi32(InReg,23)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 25);          // tmp = _mm_srli_epi32(InReg,25)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26);          // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 27);          // tmp = _mm_srli_epi32(InReg,27)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28);          // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 29);          // tmp = _mm_srli_epi32(InReg,29)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30);          // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 31);          // tmp = _mm_srli_epi32(InReg,31)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR2(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 2) - 1); // _mm_set1_epi32((1U<<2)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18);          // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22);          // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26);          // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28);          // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30);          // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18);          // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22);          // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26);          // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28);          // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30);          // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR3(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 3) - 1); // _mm_set1_epi32((1U<<3)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 3);           // tmp = _mm_srli_epi32(InReg,3)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 9);           // tmp = _mm_srli_epi32(InReg,9)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 15);          // tmp = _mm_srli_epi32(InReg,15)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18);          // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 21);          // tmp = _mm_srli_epi32(InReg,21)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 27);          // tmp = _mm_srli_epi32(InReg,27)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 3 - 1) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 3-1), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 1);           // tmp = _mm_srli_epi32(InReg,1)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 7);           // tmp = _mm_srli_epi32(InReg,7)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 13);          // tmp = _mm_srli_epi32(InReg,13)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 19);          // tmp = _mm_srli_epi32(InReg,19)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22);          // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 25);          // tmp = _mm_srli_epi32(InReg,25)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28);          // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 31); // tmp = _mm_srli_epi32(InReg,31)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 3 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 3-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 5);           // tmp = _mm_srli_epi32(InReg,5)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 11);          // tmp = _mm_srli_epi32(InReg,11)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 17);          // tmp = _mm_srli_epi32(InReg,17)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 23);          // tmp = _mm_srli_epi32(InReg,23)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26);          // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 29);          // tmp = _mm_srli_epi32(InReg,29)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR4(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 4) - 1); // _mm_set1_epi32((1U<<4)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28);          // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28);          // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28);          // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28);          // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR5(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 5) - 1); // _mm_set1_epi32((1U<<5)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 5);           // tmp = _mm_srli_epi32(InReg,5)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 15);          // tmp = _mm_srli_epi32(InReg,15)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 25);          // tmp = _mm_srli_epi32(InReg,25)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 5 - 3) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 5-3), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 3);           // tmp = _mm_srli_epi32(InReg,3)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 13);          // tmp = _mm_srli_epi32(InReg,13)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18);          // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 23);          // tmp = _mm_srli_epi32(InReg,23)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 5 - 1) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 5-1), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 1);           // tmp = _mm_srli_epi32(InReg,1)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 11);          // tmp = _mm_srli_epi32(InReg,11)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 21);          // tmp = _mm_srli_epi32(InReg,21)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26);          // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 31); // tmp = _mm_srli_epi32(InReg,31)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 5 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 5-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 9);           // tmp = _mm_srli_epi32(InReg,9)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 19);          // tmp = _mm_srli_epi32(InReg,19)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 29); // tmp = _mm_srli_epi32(InReg,29)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 5 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 5-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 7);           // tmp = _mm_srli_epi32(InReg,7)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 17);          // tmp = _mm_srli_epi32(InReg,17)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22);          // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 27);          // tmp = _mm_srli_epi32(InReg,27)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR6(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 6) - 1); // _mm_set1_epi32((1U<<6)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18);          // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 6 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 6-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22);          // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 6 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 6-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26);          // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18);          // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 6 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 6-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22);          // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 6 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 6-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26);          // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR7(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 7) - 1); // _mm_set1_epi32((1U<<7)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 7);           // tmp = _mm_srli_epi32(InReg,7)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 21);          // tmp = _mm_srli_epi32(InReg,21)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 7 - 3) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 7-3), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 3);           // tmp = _mm_srli_epi32(InReg,3)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 17);          // tmp = _mm_srli_epi32(InReg,17)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 31); // tmp = _mm_srli_epi32(InReg,31)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 7 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 7-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 13);          // tmp = _mm_srli_epi32(InReg,13)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 27); // tmp = _mm_srli_epi32(InReg,27)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 7 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 7-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 9);           // tmp = _mm_srli_epi32(InReg,9)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 23);          // tmp = _mm_srli_epi32(InReg,23)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 7 - 5) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 7-5), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 5);           // tmp = _mm_srli_epi32(InReg,5)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 19);          // tmp = _mm_srli_epi32(InReg,19)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 7 - 1) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 7-1), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 1);           // tmp = _mm_srli_epi32(InReg,1)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 15);          // tmp = _mm_srli_epi32(InReg,15)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22);          // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 29); // tmp = _mm_srli_epi32(InReg,29)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 7 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 7-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 11);          // tmp = _mm_srli_epi32(InReg,11)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18);          // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 25);          // tmp = _mm_srli_epi32(InReg,25)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR8(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 8) - 1); // _mm_set1_epi32((1U<<8)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24);          // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR9(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 9) - 1); // _mm_set1_epi32((1U<<9)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 9);           // tmp = _mm_srli_epi32(InReg,9)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18);          // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 27); // tmp = _mm_srli_epi32(InReg,27)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 9 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 9-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 13);          // tmp = _mm_srli_epi32(InReg,13)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22);          // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 31); // tmp = _mm_srli_epi32(InReg,31)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 9 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 9-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 17);          // tmp = _mm_srli_epi32(InReg,17)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 9 - 3) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 9-3), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 3);           // tmp = _mm_srli_epi32(InReg,3)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 21);          // tmp = _mm_srli_epi32(InReg,21)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 9 - 7) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 9-7), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 7);           // tmp = _mm_srli_epi32(InReg,7)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 25); // tmp = _mm_srli_epi32(InReg,25)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 9 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 9-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 11);          // tmp = _mm_srli_epi32(InReg,11)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 29); // tmp = _mm_srli_epi32(InReg,29)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 9 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 9-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 15);          // tmp = _mm_srli_epi32(InReg,15)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 9 - 1) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 9-1), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 1);           // tmp = _mm_srli_epi32(InReg,1)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 19);          // tmp = _mm_srli_epi32(InReg,19)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 9 - 5) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 9-5), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 5);           // tmp = _mm_srli_epi32(InReg,5)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 23);          // tmp = _mm_srli_epi32(InReg,23)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR10(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 10) - 1); // _mm_set1_epi32((1U<<10)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 10 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 10-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18);          // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 10 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 10-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 10 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 10-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 10 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 10-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22);          // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 10 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 10-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18);          // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 10 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 10-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 10 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 10-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 10 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 10-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22);          // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR11(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 11) - 1); // _mm_set1_epi32((1U<<11)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 11);          // tmp = _mm_srli_epi32(InReg,11)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 11 - 1) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 11-1), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 1);           // tmp = _mm_srli_epi32(InReg,1)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 23); // tmp = _mm_srli_epi32(InReg,23)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 11 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 11-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 13);          // tmp = _mm_srli_epi32(InReg,13)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 11 - 3) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 11-3), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 3);           // tmp = _mm_srli_epi32(InReg,3)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 25); // tmp = _mm_srli_epi32(InReg,25)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 11 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 11-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 15);          // tmp = _mm_srli_epi32(InReg,15)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 11 - 5) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 11-5), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 5);           // tmp = _mm_srli_epi32(InReg,5)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 27); // tmp = _mm_srli_epi32(InReg,27)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 11 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 11-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 17);          // tmp = _mm_srli_epi32(InReg,17)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 11 - 7) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 11-7), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 7);           // tmp = _mm_srli_epi32(InReg,7)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18);          // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 29); // tmp = _mm_srli_epi32(InReg,29)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 11 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 11-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 19);          // tmp = _mm_srli_epi32(InReg,19)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 11 - 9) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 11-9), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 9);           // tmp = _mm_srli_epi32(InReg,9)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 31); // tmp = _mm_srli_epi32(InReg,31)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 11 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 11-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 21);          // tmp = _mm_srli_epi32(InReg,21)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR12(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 12) - 1); // _mm_set1_epi32((1U<<12)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 12 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 12-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 12 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 12-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 12 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 12-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 12 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 12-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 12 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 12-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 12 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 12-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 12 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 12-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 12 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 12-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20);          // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR13(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 13) - 1); // _mm_set1_epi32((1U<<13)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 13);          // tmp = _mm_srli_epi32(InReg,13)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 13 - 7) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 13-7), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 7);           // tmp = _mm_srli_epi32(InReg,7)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 13 - 1) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 13-1), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 1);           // tmp = _mm_srli_epi32(InReg,1)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 27); // tmp = _mm_srli_epi32(InReg,27)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 13 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 13-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 21); // tmp = _mm_srli_epi32(InReg,21)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 13 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 13-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 15);          // tmp = _mm_srli_epi32(InReg,15)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 13 - 9) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 13-9), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 9);           // tmp = _mm_srli_epi32(InReg,9)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 13 - 3) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 13-3), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 3);           // tmp = _mm_srli_epi32(InReg,3)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 29); // tmp = _mm_srli_epi32(InReg,29)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 13 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 13-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 23); // tmp = _mm_srli_epi32(InReg,23)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 13 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 13-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 17);          // tmp = _mm_srli_epi32(InReg,17)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 13 - 11) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 13-11), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 11);          // tmp = _mm_srli_epi32(InReg,11)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 13 - 5) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 13-5), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 5);           // tmp = _mm_srli_epi32(InReg,5)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18);          // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 31); // tmp = _mm_srli_epi32(InReg,31)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 13 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 13-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 25); // tmp = _mm_srli_epi32(InReg,25)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 13 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 13-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 19);          // tmp = _mm_srli_epi32(InReg,19)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR14(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 14) - 1); // _mm_set1_epi32((1U<<14)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 14 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 14-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 14 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 14-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 14 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 14-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 14 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 14-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 14 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 14-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 14 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 14-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18);          // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 14 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 14-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 14 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 14-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 14 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 14-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 14 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 14-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 14 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 14-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 14 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 14-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18);          // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR15(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 15) - 1); // _mm_set1_epi32((1U<<15)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 15);          // tmp = _mm_srli_epi32(InReg,15)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 15 - 13) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 15-13), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 13);          // tmp = _mm_srli_epi32(InReg,13)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 15 - 11) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 15-11), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 11);          // tmp = _mm_srli_epi32(InReg,11)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 15 - 9) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 15-9), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 9);           // tmp = _mm_srli_epi32(InReg,9)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 15 - 7) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 15-7), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 7);           // tmp = _mm_srli_epi32(InReg,7)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 15 - 5) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 15-5), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 5);           // tmp = _mm_srli_epi32(InReg,5)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 15 - 3) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 15-3), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 3);           // tmp = _mm_srli_epi32(InReg,3)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18); // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 15 - 1) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 15-1), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 1);           // tmp = _mm_srli_epi32(InReg,1)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 31); // tmp = _mm_srli_epi32(InReg,31)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 15 - 14) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 15-14), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 29); // tmp = _mm_srli_epi32(InReg,29)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 15 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 15-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 27); // tmp = _mm_srli_epi32(InReg,27)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 15 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 15-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 25); // tmp = _mm_srli_epi32(InReg,25)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 15 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 15-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 23); // tmp = _mm_srli_epi32(InReg,23)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 15 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 15-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 21); // tmp = _mm_srli_epi32(InReg,21)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 15 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 15-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 19); // tmp = _mm_srli_epi32(InReg,19)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 15 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 15-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 17);          // tmp = _mm_srli_epi32(InReg,17)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR16(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 16) - 1); // _mm_set1_epi32((1U<<16)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16);          // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR17(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 17) - 1); // _mm_set1_epi32((1U<<17)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 17); // tmp = _mm_srli_epi32(InReg,17)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 17 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 17-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 19); // tmp = _mm_srli_epi32(InReg,19)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 17 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 17-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 21); // tmp = _mm_srli_epi32(InReg,21)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 17 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 17-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 23); // tmp = _mm_srli_epi32(InReg,23)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 17 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 17-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 25); // tmp = _mm_srli_epi32(InReg,25)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 17 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 17-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 27); // tmp = _mm_srli_epi32(InReg,27)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 17 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 17-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 29); // tmp = _mm_srli_epi32(InReg,29)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 17 - 14) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 17-14), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 31); // tmp = _mm_srli_epi32(InReg,31)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 17 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 17-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 17 - 1) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 17-1), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 1);           // tmp = _mm_srli_epi32(InReg,1)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18); // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 17 - 3) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 17-3), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 3);           // tmp = _mm_srli_epi32(InReg,3)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 17 - 5) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 17-5), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 5);           // tmp = _mm_srli_epi32(InReg,5)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 17 - 7) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 17-7), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 7);           // tmp = _mm_srli_epi32(InReg,7)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 17 - 9) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 17-9), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 9);           // tmp = _mm_srli_epi32(InReg,9)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 17 - 11) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 17-11), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 11);          // tmp = _mm_srli_epi32(InReg,11)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 17 - 13) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 17-13), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 13);          // tmp = _mm_srli_epi32(InReg,13)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 17 - 15) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 17-15), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 15);          // tmp = _mm_srli_epi32(InReg,15)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR18(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 18) - 1); // _mm_set1_epi32((1U<<18)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18); // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 18 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 18-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 18 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 18-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 18 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 18-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 18 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 18-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 18 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 18-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 18 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 18-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 18 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 18-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 18 - 14) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 18-14), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18); // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 18 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 18-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 18 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 18-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 18 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 18-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 18 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 18-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 18 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 18-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 18 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 18-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 18 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 18-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 18 - 14) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 18-14), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14);          // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR19(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 19) - 1); // _mm_set1_epi32((1U<<19)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 19); // tmp = _mm_srli_epi32(InReg,19)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 25); // tmp = _mm_srli_epi32(InReg,25)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 31); // tmp = _mm_srli_epi32(InReg,31)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 18) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-18), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18); // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 5) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-5), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 5);           // tmp = _mm_srli_epi32(InReg,5)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 11) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-11), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 11);          // tmp = _mm_srli_epi32(InReg,11)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 17) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-17), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 17); // tmp = _mm_srli_epi32(InReg,17)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 23); // tmp = _mm_srli_epi32(InReg,23)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 29); // tmp = _mm_srli_epi32(InReg,29)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 3) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-3), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 3);           // tmp = _mm_srli_epi32(InReg,3)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 9) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-9), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 9);           // tmp = _mm_srli_epi32(InReg,9)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 15) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-15), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 15); // tmp = _mm_srli_epi32(InReg,15)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 21); // tmp = _mm_srli_epi32(InReg,21)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 27); // tmp = _mm_srli_epi32(InReg,27)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 14) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-14), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14); // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 1) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-1), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 1);           // tmp = _mm_srli_epi32(InReg,1)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 7) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-7), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 7);           // tmp = _mm_srli_epi32(InReg,7)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 19 - 13) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 19-13), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 13);          // tmp = _mm_srli_epi32(InReg,13)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR20(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 20) - 1); // _mm_set1_epi32((1U<<20)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 20 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 20-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 20 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 20-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 20 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 20-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 20 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 20-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 20 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 20-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 20 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 20-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 20 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 20-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 20 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 20-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 20 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 20-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 20 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 20-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 20 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 20-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 20 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 20-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 20 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 20-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 20 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 20-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 20 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 20-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 20 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 20-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12);          // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR21(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 21) - 1); // _mm_set1_epi32((1U<<21)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 21); // tmp = _mm_srli_epi32(InReg,21)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 31); // tmp = _mm_srli_epi32(InReg,31)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 20) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-20), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 9) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-9), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 9);           // tmp = _mm_srli_epi32(InReg,9)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 19) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-19), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 19); // tmp = _mm_srli_epi32(InReg,19)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 29); // tmp = _mm_srli_epi32(InReg,29)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 18) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-18), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18); // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 7) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-7), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 7);           // tmp = _mm_srli_epi32(InReg,7)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 17) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-17), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 17); // tmp = _mm_srli_epi32(InReg,17)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 27); // tmp = _mm_srli_epi32(InReg,27)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 5) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-5), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 5);           // tmp = _mm_srli_epi32(InReg,5)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 15) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-15), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 15); // tmp = _mm_srli_epi32(InReg,15)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 25); // tmp = _mm_srli_epi32(InReg,25)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 14) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-14), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14); // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 3) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-3), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 3);           // tmp = _mm_srli_epi32(InReg,3)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 13) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-13), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 13); // tmp = _mm_srli_epi32(InReg,13)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 23); // tmp = _mm_srli_epi32(InReg,23)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12); // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 1) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-1), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 1);           // tmp = _mm_srli_epi32(InReg,1)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 21 - 11) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 21-11), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 11);          // tmp = _mm_srli_epi32(InReg,11)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR22(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 22) - 1); // _mm_set1_epi32((1U<<22)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12); // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 14) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-14), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14); // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 18) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-18), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18); // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 20) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-20), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12); // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 14) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-14), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14); // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 18) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-18), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18); // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 20) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-20), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 22 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 22-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10);          // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR23(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 23) - 1); // _mm_set1_epi32((1U<<23)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 23); // tmp = _mm_srli_epi32(InReg,23)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 14) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-14), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14); // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 5) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-5), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 5);           // tmp = _mm_srli_epi32(InReg,5)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 19) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-19), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 19); // tmp = _mm_srli_epi32(InReg,19)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10); // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 1) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-1), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 1);           // tmp = _mm_srli_epi32(InReg,1)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 15) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-15), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 15); // tmp = _mm_srli_epi32(InReg,15)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 29); // tmp = _mm_srli_epi32(InReg,29)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 20) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-20), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 11) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-11), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 11); // tmp = _mm_srli_epi32(InReg,11)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 25); // tmp = _mm_srli_epi32(InReg,25)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 7) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-7), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 7);           // tmp = _mm_srli_epi32(InReg,7)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 21) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-21), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 21); // tmp = _mm_srli_epi32(InReg,21)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12); // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 3) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-3), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 3);           // tmp = _mm_srli_epi32(InReg,3)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 17) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-17), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 17); // tmp = _mm_srli_epi32(InReg,17)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 31); // tmp = _mm_srli_epi32(InReg,31)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 22) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-22), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 13) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-13), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 13); // tmp = _mm_srli_epi32(InReg,13)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 27); // tmp = _mm_srli_epi32(InReg,27)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 18) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-18), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18); // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 23 - 9) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 23-9), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 9);           // tmp = _mm_srli_epi32(InReg,9)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR24(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 24) - 1); // _mm_set1_epi32((1U<<24)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 24 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 24-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 24 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 24-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 24 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 24-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 24 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 24-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 24 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 24-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 24 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 24-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 24 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 24-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 24 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 24-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 24 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 24-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 24 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 24-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 24 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 24-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 24 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 24-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 24 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 24-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 24 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 24-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 24 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 24-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 24 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 24-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8);           // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR25(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 25) - 1); // _mm_set1_epi32((1U<<25)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 25); // tmp = _mm_srli_epi32(InReg,25)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 18) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-18), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18); // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 11) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-11), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 11); // tmp = _mm_srli_epi32(InReg,11)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 29); // tmp = _mm_srli_epi32(InReg,29)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 22) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-22), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 15) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-15), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 15); // tmp = _mm_srli_epi32(InReg,15)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8); // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 1) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-1), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 1);           // tmp = _mm_srli_epi32(InReg,1)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 19) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-19), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 19); // tmp = _mm_srli_epi32(InReg,19)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12); // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 5) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-5), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 5);           // tmp = _mm_srli_epi32(InReg,5)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 23) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-23), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 23); // tmp = _mm_srli_epi32(InReg,23)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 9) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-9), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 9); // tmp = _mm_srli_epi32(InReg,9)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 27); // tmp = _mm_srli_epi32(InReg,27)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 20) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-20), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 13) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-13), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 13); // tmp = _mm_srli_epi32(InReg,13)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 31); // tmp = _mm_srli_epi32(InReg,31)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 24) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-24), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 17) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-17), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 17); // tmp = _mm_srli_epi32(InReg,17)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10); // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 3) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-3), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 3);           // tmp = _mm_srli_epi32(InReg,3)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 21) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-21), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 21); // tmp = _mm_srli_epi32(InReg,21)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 14) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-14), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14); // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 25 - 7) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 25-7), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 7);           // tmp = _mm_srli_epi32(InReg,7)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR26(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 26) - 1); // _mm_set1_epi32((1U<<26)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 20) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-20), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 14) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-14), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14); // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8); // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 22) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-22), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10); // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 24) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-24), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 18) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-18), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18); // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12); // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 20) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-20), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 14) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-14), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14); // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8); // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 22) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-22), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10); // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 24) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-24), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 18) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-18), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18); // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12); // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 26 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 26-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6);           // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR27(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 27) - 1); // _mm_set1_epi32((1U<<27)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 27); // tmp = _mm_srli_epi32(InReg,27)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 22) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-22), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 17) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-17), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 17); // tmp = _mm_srli_epi32(InReg,17)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12); // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 7) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-7), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 7); // tmp = _mm_srli_epi32(InReg,7)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 29); // tmp = _mm_srli_epi32(InReg,29)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 24) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-24), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 19) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-19), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 19); // tmp = _mm_srli_epi32(InReg,19)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 14) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-14), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14); // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 9) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-9), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 9); // tmp = _mm_srli_epi32(InReg,9)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 31); // tmp = _mm_srli_epi32(InReg,31)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 26) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-26), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 21) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-21), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 21); // tmp = _mm_srli_epi32(InReg,21)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 11) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-11), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 11); // tmp = _mm_srli_epi32(InReg,11)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6); // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 1) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-1), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 1);           // tmp = _mm_srli_epi32(InReg,1)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 23) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-23), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 23); // tmp = _mm_srli_epi32(InReg,23)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 18) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-18), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18); // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 13) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-13), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 13); // tmp = _mm_srli_epi32(InReg,13)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8); // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 3) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-3), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 3);           // tmp = _mm_srli_epi32(InReg,3)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 25) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-25), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 25); // tmp = _mm_srli_epi32(InReg,25)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 20) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-20), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 15) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-15), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 15); // tmp = _mm_srli_epi32(InReg,15)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10); // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 27 - 5) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 27-5), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 5);           // tmp = _mm_srli_epi32(InReg,5)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR28(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 28) - 1); // _mm_set1_epi32((1U<<28)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 24) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-24), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 20) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-20), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12); // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8); // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 24) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-24), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 20) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-20), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12); // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8); // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 24) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-24), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 20) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-20), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12); // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8); // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 24) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-24), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 20) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-20), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12); // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8); // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 28 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 28-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4);           // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR29(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 29) - 1); // _mm_set1_epi32((1U<<29)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 29); // tmp = _mm_srli_epi32(InReg,29)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 26) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-26), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 23) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-23), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 23); // tmp = _mm_srli_epi32(InReg,23)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 20) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-20), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 17) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-17), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 17); // tmp = _mm_srli_epi32(InReg,17)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 14) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-14), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14); // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 11) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-11), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 11); // tmp = _mm_srli_epi32(InReg,11)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8); // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 5) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-5), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 5); // tmp = _mm_srli_epi32(InReg,5)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 31); // tmp = _mm_srli_epi32(InReg,31)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 28) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-28), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 25) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-25), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 25); // tmp = _mm_srli_epi32(InReg,25)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 22) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-22), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 19) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-19), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 19); // tmp = _mm_srli_epi32(InReg,19)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 13) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-13), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 13); // tmp = _mm_srli_epi32(InReg,13)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10); // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 7) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-7), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 7); // tmp = _mm_srli_epi32(InReg,7)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4); // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 1) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-1), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 1);           // tmp = _mm_srli_epi32(InReg,1)
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 27) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-27), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 27); // tmp = _mm_srli_epi32(InReg,27)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 24) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-24), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 21) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-21), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 21); // tmp = _mm_srli_epi32(InReg,21)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 18) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-18), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18); // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 15) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-15), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 15); // tmp = _mm_srli_epi32(InReg,15)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12); // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 9) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-9), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 9); // tmp = _mm_srli_epi32(InReg,9)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6); // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 29 - 3) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 29-3), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 3);           // tmp = _mm_srli_epi32(InReg,3)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR30(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 30) - 1); // _mm_set1_epi32((1U<<30)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 28) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-28), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 26) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-26), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 24) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-24), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 22) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-22), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 20) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-20), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 18) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-18), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18); // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 14) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-14), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14); // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12); // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10); // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8); // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6); // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4); // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp;                                          // OutReg = tmp;
        ++input;                                               // ++in;
        inReg = *input;                                        // InReg = _mm_load_si128(in);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 28) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-28), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 26) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-26), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 24) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-24), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 22) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-22), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 20) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-20), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 18) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-18), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18); // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 14) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-14), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14); // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12); // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10); // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8); // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6); // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4); // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 30 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 30-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2);           // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR31(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {

        var inReg = *input;
        Vector256<uint> outReg;
        Vector256<uint> tmp;
        
        Vector256<uint> mask = Vector256.Create((1U << 31) - 1); // _mm_set1_epi32((1U<<31)-1);

        tmp = inReg;                                           // tmp = InReg;
        outReg = tmp & mask;                                   // OutReg = _mm_and_si128(tmp, mask);
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 31); // tmp = _mm_srli_epi32(InReg,31)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 30) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-30), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 30); // tmp = _mm_srli_epi32(InReg,30)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 29) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-29), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 29); // tmp = _mm_srli_epi32(InReg,29)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 28) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-28), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 28); // tmp = _mm_srli_epi32(InReg,28)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 27) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-27), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 27); // tmp = _mm_srli_epi32(InReg,27)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 26) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-26), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 26); // tmp = _mm_srli_epi32(InReg,26)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 25) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-25), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 25); // tmp = _mm_srli_epi32(InReg,25)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 24) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-24), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 24); // tmp = _mm_srli_epi32(InReg,24)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 23) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-23), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 23); // tmp = _mm_srli_epi32(InReg,23)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 22) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-22), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 22); // tmp = _mm_srli_epi32(InReg,22)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 21) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-21), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 21); // tmp = _mm_srli_epi32(InReg,21)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 20) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-20), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 20); // tmp = _mm_srli_epi32(InReg,20)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 19) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-19), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 19); // tmp = _mm_srli_epi32(InReg,19)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 18) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-18), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 18); // tmp = _mm_srli_epi32(InReg,18)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 17) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-17), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 17); // tmp = _mm_srli_epi32(InReg,17)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 16) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-16), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 16); // tmp = _mm_srli_epi32(InReg,16)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 15) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-15), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 15); // tmp = _mm_srli_epi32(InReg,15)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 14) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-14), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 14); // tmp = _mm_srli_epi32(InReg,14)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 13) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-13), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 13); // tmp = _mm_srli_epi32(InReg,13)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 12) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-12), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 12); // tmp = _mm_srli_epi32(InReg,12)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 11) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-11), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 11); // tmp = _mm_srli_epi32(InReg,11)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 10) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-10), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 10); // tmp = _mm_srli_epi32(InReg,10)
        outReg = tmp;                                 // OutReg = tmp;
        ++input;                                      // ++in;
        inReg = *input;                               // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 9) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-9), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 9); // tmp = _mm_srli_epi32(InReg,9)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 8) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-8), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 8); // tmp = _mm_srli_epi32(InReg,8)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 7) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-7), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 7); // tmp = _mm_srli_epi32(InReg,7)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 6) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-6), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 6); // tmp = _mm_srli_epi32(InReg,6)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 5) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-5), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 5); // tmp = _mm_srli_epi32(InReg,5)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 4) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-4), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 4); // tmp = _mm_srli_epi32(InReg,4)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 3) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-3), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 3); // tmp = _mm_srli_epi32(InReg,3)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 2) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-2), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 2); // tmp = _mm_srli_epi32(InReg,2)
        outReg = tmp;                                // OutReg = tmp;
        ++input;                                     // ++in;
        inReg = *input;                              // InReg = _mm_load_si128(in);
        outReg |= Vector256.ShiftLeft(inReg, 31 - 1) &
                  mask; //  OutReg = _mm_or_si128(OutReg, _mm_and_si128(_mm_slli_epi32(InReg, 31-1), mask));

        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);

        tmp = Vector256.ShiftRightLogical(inReg, 1);           // tmp = _mm_srli_epi32(InReg,1)
        outReg = tmp;                                          // OutReg = tmp;
        outReg = simdTransform.Decode(outReg, ref initOffset); //  PrefixSum(OutReg, OutReg, initOffset);
                                                               //    initOffset = OutReg;
        *output++ = outReg;                                    //_mm_store_si128(out++, OutReg);
    }

  public
    static void iunpackFOR32(Vector256<uint> initOffset, Vector256<uint> *input, Vector256<uint> *output, TTransform simdTransform)
    {
        for (int k = 0; k < 256 / 8; ++k)
        {
            *output++ = *input++;
        }
    }
}

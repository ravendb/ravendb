<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ICSharpCode.NRefactory</name>
    </assembly>
    <members>
        <member name="T:ICSharpCode.NRefactory.Documentation.IDStringProvider">
            <summary>
            Provides ID strings for entities. (C# 4.0 spec, §A.3.1)
            ID strings are used to identify members in XML documentation files.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.IDStringProvider.GetIDString(ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <summary>
            Gets the ID string (C# 4.0 spec, §A.3.1) for the specified entity.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.IDocument">
            <summary>
            A document representing a source code file for refactoring.
            Line and column counting starts at 1.
            Offset counting starts at 0.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.ITextSource">
            <summary>
            A read-only view on a (potentially mutable) text source.
            The IDocument interfaces derives from this interface.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.CreateSnapshot">
            <summary>
            Creates an immutable snapshot of this text source.
            Unlike all other methods in this interface, this method is thread-safe.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.CreateSnapshot(System.Int32,System.Int32)">
            <summary>
            Creates an immutable snapshot of a part of this text source.
            Unlike all other methods in this interface, this method is thread-safe.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.CreateReader">
            <summary>
            Creates a new TextReader to read from this text source.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.CreateReader(System.Int32,System.Int32)">
            <summary>
            Creates a new TextReader to read from this text source.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.GetCharAt(System.Int32)">
            <summary>
            Gets a character at the specified position in the document.
            </summary>
            <paramref name="offset">The index of the character to get.</paramref>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset is outside the valid range (0 to TextLength-1).</exception>
            <returns>The character at the specified position.</returns>
            <remarks>This is the same as Text[offset], but is more efficient because
             it doesn't require creating a String object.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.GetText(System.Int32,System.Int32)">
            <summary>
            Retrieves the text for a portion of the document.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or length is outside the valid range.</exception>
            <remarks>This is the same as Text.Substring, but is more efficient because
             it doesn't require creating a String object for the whole document.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.GetText(ICSharpCode.NRefactory.Editor.ISegment)">
            <summary>
            Retrieves the text for a portion of the document.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or length is outside the valid range.</exception>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.IndexOfAny(System.Char[],System.Int32,System.Int32)">
            <summary>
            Gets the index of the first occurrence of any character in the specified array.
            </summary>
            <param name="anyOf">Characters to search for</param>
            <param name="startIndex">Start index of the area to search.</param>
            <param name="count">Length of the area to search.</param>
            <returns>The first index where any character was found; or -1 if no occurrence was found.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Gets the index of the first occurrence of the specified search text in this text source.
            </summary>
            <param name="searchText">The search text</param>
            <param name="startIndex">Start index of the area to search.</param>
            <param name="count">Length of the area to search.</param>
            <param name="comparisonType">String comparison to use.</param>
            <returns>The first index where the search term was found; or -1 if no occurrence was found.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSource.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Gets the index of the last occurrence of the specified search text in this text source.
            </summary>
            <param name="searchText">The search text</param>
            <param name="startIndex">Start index of the area to search.</param>
            <param name="count">Length of the area to search.</param>
            <param name="comparisonType">String comparison to use.</param>
            <returns>The last index where the search term was found; or -1 if no occurrence was found.</returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextSource.Version">
            <summary>
            Gets a version identifier for this text source.
            Returns null for unversioned text sources.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextSource.TextLength">
            <summary>
            Gets the total text length.
            </summary>
            <returns>The length of the text, in characters.</returns>
            <remarks>This is the same as Text.Length, but is more efficient because
             it doesn't require creating a String object.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextSource.Text">
            <summary>
            Gets the whole text as string.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.GetLineByNumber(System.Int32)">
            <summary>
            Gets the document line with the specified number.
            </summary>
            <param name="lineNumber">The number of the line to retrieve. The first line has number 1.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.GetLineByOffset(System.Int32)">
            <summary>
            Gets the document line that contains the specified offset.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.GetOffset(System.Int32,System.Int32)">
            <summary>
            Gets the offset from a text location.
            </summary>
            <seealso cref="M:ICSharpCode.NRefactory.Editor.IDocument.GetLocation(System.Int32)"/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.GetOffset(ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Gets the offset from a text location.
            </summary>
            <seealso cref="M:ICSharpCode.NRefactory.Editor.IDocument.GetLocation(System.Int32)"/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.GetLocation(System.Int32)">
            <summary>
            Gets the location from an offset.
            </summary>
            <seealso cref="M:ICSharpCode.NRefactory.Editor.IDocument.GetOffset(ICSharpCode.NRefactory.TextLocation)"/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.Insert(System.Int32,System.String)">
            <summary>
            Inserts text.
            </summary>
            <param name="offset">The offset at which the text is inserted.</param>
            <param name="text">The new text.</param>
            <remarks>
            Anchors positioned exactly at the insertion offset will move according to their movement type.
            For AnchorMovementType.Default, they will move behind the inserted text.
            The caret will also move behind the inserted text.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.Insert(System.Int32,System.String,ICSharpCode.NRefactory.Editor.AnchorMovementType)">
            <summary>
            Inserts text.
            </summary>
            <param name="offset">The offset at which the text is inserted.</param>
            <param name="text">The new text.</param>
            <param name="defaultAnchorMovementType">
            Anchors positioned exactly at the insertion offset will move according to the anchor's movement type.
            For AnchorMovementType.Default, they will move according to the movement type specified by this parameter.
            The caret will also move according to the <paramref name="defaultAnchorMovementType"/> parameter.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.Remove(System.Int32,System.Int32)">
            <summary>
            Removes text.
            </summary>
            <param name="offset">Starting offset of the text to be removed.</param>
            <param name="length">Length of the text to be removed.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.Replace(System.Int32,System.Int32,System.String)">
            <summary>
            Replaces text.
            </summary>
            <param name="offset">The starting offset of the text to be replaced.</param>
            <param name="length">The length of the text to be replaced.</param>
            <param name="newText">The new text.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.StartUndoableAction">
            <summary>
            Make the document combine the following actions into a single
            action for undo purposes.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.EndUndoableAction">
            <summary>
            Ends the undoable action started with <see cref="M:ICSharpCode.NRefactory.Editor.IDocument.StartUndoableAction"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.OpenUndoGroup">
            <summary>
            Creates an undo group. Dispose the returned value to close the undo group.
            </summary>
            <returns>An object that closes the undo group when Dispose() is called.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.IDocument.CreateAnchor(System.Int32)">
            <summary>
            Creates a new <see cref="T:ICSharpCode.NRefactory.Editor.ITextAnchor"/> at the specified offset.
            </summary>
            <inheritdoc cref="T:ICSharpCode.NRefactory.Editor.ITextAnchor" select="remarks|example"/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.IDocument.Text">
            <summary>
            Gets/Sets the text of the whole document..
            </summary>
        </member>
        <member name="E:ICSharpCode.NRefactory.Editor.IDocument.TextChanging">
            <summary>
            This event is called directly before a change is applied to the document.
            </summary>
            <remarks>
            It is invalid to modify the document within this event handler.
            Aborting the change (by throwing an exception) is likely to cause corruption of data structures
            that listen to the Changing and Changed events.
            </remarks>
        </member>
        <member name="E:ICSharpCode.NRefactory.Editor.IDocument.TextChanged">
            <summary>
            This event is called directly after a change is applied to the document.
            </summary>
            <remarks>
            It is invalid to modify the document within this event handler.
            Aborting the event handler (by throwing an exception) is likely to cause corruption of data structures
            that listen to the Changing and Changed events.
            </remarks>
        </member>
        <member name="E:ICSharpCode.NRefactory.Editor.IDocument.ChangeCompleted">
            <summary>
            This event is called after a group of changes is completed.
            </summary>
            <seealso cref="M:ICSharpCode.NRefactory.Editor.IDocument.EndUndoableAction"/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.IDocument.LineCount">
            <summary>
            Gets the number of lines in the document.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.IDocumentLine">
            <summary>
            A line inside a <see cref="T:ICSharpCode.NRefactory.Editor.IDocument"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.ISegment">
            <summary>
            An (Offset,Length)-pair.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ISegment.Offset">
            <summary>
            Gets the start offset of the segment.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ISegment.Length">
            <summary>
            Gets the length of the segment.
            </summary>
            <remarks>For line segments (IDocumentLine), the length does not include the line delimeter.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ISegment.EndOffset">
            <summary>
            Gets the end offset of the segment.
            </summary>
            <remarks>EndOffset = Offset + Length;</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.IDocumentLine.TotalLength">
            <summary>
            Gets the length of this line, including the line delimiter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.IDocumentLine.DelimiterLength">
            <summary>
            Gets the length of the line terminator.
            Returns 1 or 2; or 0 at the end of the document.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.IDocumentLine.LineNumber">
            <summary>
            Gets the number of this line.
            The first line has the number 1.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.IDocumentLine.PreviousLine">
            <summary>
            Gets the previous line. Returns null if this is the first line in the document.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.IDocumentLine.NextLine">
            <summary>
            Gets the next line. Returns null if this is the last line in the document.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.ISegmentExtensions">
            <summary>
            Extension methods for <see cref="T:ICSharpCode.NRefactory.Editor.ISegment"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ISegmentExtensions.Contains(ICSharpCode.NRefactory.Editor.ISegment,System.Int32)">
            <summary>
            Gets whether the segment contains the offset.
            </summary>
            <returns>
            True, if offset is between segment.Start and segment.End (inclusive); otherwise, false.
            </returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ISegmentExtensions.Contains(ICSharpCode.NRefactory.Editor.ISegment,ICSharpCode.NRefactory.Editor.ISegment)">
            <summary>
            True, if the segment contains the specified segment, false otherwise.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.ITextAnchor">
            <summary>
            The TextAnchor class references an offset (a position between two characters).
            It automatically updates the offset when text is inserted/removed in front of the anchor.
            </summary>
            <remarks>
            <para>Use the <see cref="P:ICSharpCode.NRefactory.Editor.ITextAnchor.Offset"/> property to get the offset from a text anchor.
            Use the <see cref="M:ICSharpCode.NRefactory.Editor.IDocument.CreateAnchor(System.Int32)"/> method to create an anchor from an offset.
            </para>
            <para>
            The document will automatically update all text anchors; and because it uses weak references to do so,
            the garbage collector can simply collect the anchor object when you don't need it anymore.
            </para>
            <para>Moreover, the document is able to efficiently update a large number of anchors without having to look
            at each anchor object individually. Updating the offsets of all anchors usually only takes time logarithmic
            to the number of anchors. Retrieving the <see cref="P:ICSharpCode.NRefactory.Editor.ITextAnchor.Offset"/> property also runs in O(lg N).</para>
            </remarks>
            <example>
            Usage:
            <code>TextAnchor anchor = document.CreateAnchor(offset);
            ChangeMyDocument();
            int newOffset = anchor.Offset;
            </code>
            </example>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextAnchor.Location">
            <summary>
            Gets the text location of this anchor.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when trying to get the Offset from a deleted anchor.</exception>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextAnchor.Offset">
            <summary>
            Gets the offset of the text anchor.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when trying to get the Offset from a deleted anchor.</exception>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextAnchor.MovementType">
            <summary>
            Controls how the anchor moves.
            </summary>
            <remarks>Anchor movement is ambiguous if text is inserted exactly at the anchor's location.
            Does the anchor stay before the inserted text, or does it move after it?
            The property <see cref="P:ICSharpCode.NRefactory.Editor.ITextAnchor.MovementType"/> will be used to determine which of these two options the anchor will choose.
            The default value is <see cref="F:ICSharpCode.NRefactory.Editor.AnchorMovementType.Default"/>.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextAnchor.SurviveDeletion">
            <summary>
            <para>
            Specifies whether the anchor survives deletion of the text containing it.
            </para><para>
            <c>false</c>: The anchor is deleted when the a selection that includes the anchor is deleted.
            <c>true</c>: The anchor is not deleted.
            </para>
            </summary>
            <remarks><inheritdoc cref="P:ICSharpCode.NRefactory.Editor.ITextAnchor.IsDeleted"/></remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextAnchor.IsDeleted">
            <summary>
            Gets whether the anchor was deleted.
            </summary>
            <remarks>
            <para>When a piece of text containing an anchor is removed, then that anchor will be deleted.
            First, the <see cref="P:ICSharpCode.NRefactory.Editor.ITextAnchor.IsDeleted"/> property is set to true on all deleted anchors,
            then the <see cref="E:ICSharpCode.NRefactory.Editor.ITextAnchor.Deleted"/> events are raised.
            You cannot retrieve the offset from an anchor that has been deleted.</para>
            <para>This deletion behavior might be useful when using anchors for building a bookmark feature,
            but in other cases you want to still be able to use the anchor. For those cases, set <c><see cref="P:ICSharpCode.NRefactory.Editor.ITextAnchor.SurviveDeletion"/> = true</c>.</para>
            </remarks>
        </member>
        <member name="E:ICSharpCode.NRefactory.Editor.ITextAnchor.Deleted">
            <summary>
            Occurs after the anchor was deleted.
            </summary>
            <remarks>
            <inheritdoc cref="P:ICSharpCode.NRefactory.Editor.ITextAnchor.IsDeleted"/>
            <para>Due to the 'weak reference' nature of text anchors, you will receive
            the Deleted event only while your code holds a reference to the TextAnchor object.
            </para>
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextAnchor.Line">
            <summary>
            Gets the line number of the anchor.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when trying to get the Offset from a deleted anchor.</exception>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ITextAnchor.Column">
            <summary>
            Gets the column number of this anchor.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when trying to get the Offset from a deleted anchor.</exception>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.AnchorMovementType">
            <summary>
            Defines how a text anchor moves.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Editor.AnchorMovementType.Default">
            <summary>
            When text is inserted at the anchor position, the type of the insertion
            determines where the caret moves to. For normal insertions, the anchor will stay
            behind the inserted text.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Editor.AnchorMovementType.BeforeInsertion">
            <summary>
            Behaves like a start marker - when text is inserted at the anchor position, the anchor will stay
            before the inserted text.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Editor.AnchorMovementType.AfterInsertion">
            <summary>
            Behave like an end marker - when text is insered at the anchor position, the anchor will move
            after the inserted text.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.ITextSourceVersion">
            <summary>
            Represents a version identifier for a text source.
            </summary>
            <remarks>
            Verions can be used to efficiently detect whether a document has changed and needs reparsing;
            or even to implement incremental parsers.
            It is a separate class from ITextBuffer to allow the GC to collect the text buffer while
            the version checkpoint is still in use.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSourceVersion.BelongsToSameDocumentAs(ICSharpCode.NRefactory.Editor.ITextSourceVersion)">
            <summary>
            Gets whether this checkpoint belongs to the same document as the other checkpoint.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSourceVersion.CompareAge(ICSharpCode.NRefactory.Editor.ITextSourceVersion)">
            <summary>
            Compares the age of this checkpoint to the other checkpoint.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <exception cref="T:System.ArgumentException">Raised if 'other' belongs to a different document than this version.</exception>
            <returns>-1 if this version is older than <paramref name="other"/>.
            0 if <c>this</c> version instance represents the same version as <paramref name="other"/>.
            1 if this version is newer than <paramref name="other"/>.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSourceVersion.GetChangesTo(ICSharpCode.NRefactory.Editor.ITextSourceVersion)">
            <summary>
            Gets the changes from this checkpoint to the other checkpoint.
            If 'other' is older than this checkpoint, reverse changes are calculated.
            </summary>
            <remarks>This method is thread-safe.</remarks>
            <exception cref="T:System.ArgumentException">Raised if 'other' belongs to a different document than this checkpoint.</exception>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ITextSourceVersion.MoveOffsetTo(ICSharpCode.NRefactory.Editor.ITextSourceVersion,System.Int32,ICSharpCode.NRefactory.Editor.AnchorMovementType)">
            <summary>
            Calculates where the offset has moved in the other buffer version.
            </summary>
            <exception cref="T:System.ArgumentException">Raised if 'other' belongs to a different document than this checkpoint.</exception>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.ReadOnlyDocument">
            <summary>
            Read-only implementation of <see cref="T:ICSharpCode.NRefactory.Editor.IDocument"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.#ctor(ICSharpCode.NRefactory.Editor.ITextSource)">
            <summary>
            Creates a new ReadOnlyDocument from the given text source.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.#ctor(System.String)">
            <summary>
            Creates a new ReadOnlyDocument from the given string.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.GetLineByNumber(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.GetLineByOffset(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.GetOffset(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.GetOffset(ICSharpCode.NRefactory.TextLocation)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.GetLocation(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.CreateAnchor(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.CreateSnapshot">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.CreateSnapshot(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.CreateReader">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.CreateReader(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.GetCharAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.GetText(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.GetText(ICSharpCode.NRefactory.Editor.ISegment)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.IndexOfAny(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.Text">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.LineCount">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.ReadOnlyDocument.TextLength">
            <inheritdoc/>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.StringTextSource">
            <summary>
            Implements the ITextSource interface using a string.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.#ctor(System.String)">
            <summary>
            Creates a new StringTextSource with the given text.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.CreateSnapshot">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.CreateSnapshot(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.CreateReader">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.CreateReader(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.GetCharAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.GetText(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.GetText(ICSharpCode.NRefactory.Editor.ISegment)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.IndexOfAny(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.StringTextSource.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.StringTextSource.TextLength">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.StringTextSource.Text">
            <inheritdoc/>
        </member>
        <member name="T:ICSharpCode.NRefactory.Editor.TextChangeEventArgs">
            <summary>
            Describes a change of the document text.
            This class is thread-safe.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Editor.TextChangeEventArgs.#ctor(System.Int32,System.String,System.String)">
            <summary>
            Creates a new TextChangeEventArgs object.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.TextChangeEventArgs.Offset">
            <summary>
            The offset at which the change occurs.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.TextChangeEventArgs.RemovedText">
            <summary>
            The text that was removed.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.TextChangeEventArgs.RemovalLength">
            <summary>
            The number of characters removed.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.TextChangeEventArgs.InsertedText">
            <summary>
            The text that was inserted.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Editor.TextChangeEventArgs.InsertionLength">
            <summary>
            The number of characters inserted.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.IAnnotatable">
            <summary>
            Provides an interface to handle annotations in an object.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.IAnnotatable.Annotation``1">
            <summary>
            Gets the first annotation of the specified type.
            Returns null if no matching annotation exists.
            </summary>
            <typeparam name='T'>
            The type of the annotation.
            </typeparam>
        </member>
        <member name="M:ICSharpCode.NRefactory.IAnnotatable.Annotation(System.Type)">
            <summary>
            Gets the first annotation of the specified type.
            Returns null if no matching annotation exists.
            </summary>
            <param name='type'>
            The type of the annotation.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.IAnnotatable.AddAnnotation(System.Object)">
            <summary>
            Adds an annotation to this instance.
            </summary>
            <param name='annotation'>
            The annotation to add.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.IAnnotatable.RemoveAnnotations``1">
            <summary>
            Removes all annotations of the specified type.
            </summary>
            <typeparam name='T'>
            The type of the annotations to remove.
            </typeparam>
        </member>
        <member name="M:ICSharpCode.NRefactory.IAnnotatable.RemoveAnnotations(System.Type)">
            <summary>
            Removes all annotations of the specified type.
            </summary>
            <param name='type'>
            The type of the annotations to remove.
            </param>
        </member>
        <member name="P:ICSharpCode.NRefactory.IAnnotatable.Annotations">
            <summary>
            Gets all annotations stored on this IAnnotatable.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.AbstractAnnotatable.Annotations">
            <summary>
            Gets all annotations stored on this AstNode.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.BacktrackingInfo">
            <summary>
            Container for the backtracking info.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Choice">
            <summary>
            Matches one of several alternatives.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Pattern">
            <summary>
            Base class for all patterns.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.INode">
            <summary>
            AST node that supports pattern matching.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.PatternMatching.Pattern.AnyString">
            <summary>
            Gets the string that matches any string.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.AnyNode">
            <summary>
            Matches any node.
            </summary>
            <remarks>Does not match null nodes.</remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Backreference">
            <summary>
            Matches the last entry in the specified named group.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.PatternMatching.PatternExtensions.Match(ICSharpCode.NRefactory.PatternMatching.INode,ICSharpCode.NRefactory.PatternMatching.INode)">
            <summary>
            Performs a pattern matching operation.
            <c>this</c> is the pattern, <paramref name="other"/> is the AST that is being matched.
            </summary>
            <returns>
            A match object. Check <see cref="P:ICSharpCode.NRefactory.PatternMatching.Match.Success"/> to see whether the match was successful.
            </returns>
            <remarks>
            Patterns are ASTs that contain special pattern nodes (from the PatternMatching namespace).
            However, it is also possible to match two ASTs without any pattern nodes -
            doing so will produce a successful match if the two ASTs are structurally identical.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Match">
            <summary>
            Represents the result of a pattern matching operation.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.NamedNode">
            <summary>
            Represents a named node within a pattern.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.PatternMatching.Repeat">
            <summary>
            Represents an optional node.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider">
            <summary>
            Provides documentation from an .xml file (as generated by the Microsoft C# compiler).
            </summary>
            <remarks>
            This class first creates an in-memory index of the .xml file, and then uses that to read only the requested members.
            This way, we avoid keeping all the documentation in memory.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IDocumentationProvider">
            <summary>
            Provides XML documentation for members.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IDocumentationProvider.GetDocumentation(ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <summary>
            Gets the XML documentation for the specified entity.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.#ctor(System.String)">
            <summary>
            Creates a new XmlDocumentationProvider.
            </summary>
            <param name="fileName">Name of the .xml file.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.LookupLocalizedXmlDoc(System.String)">
            <summary>
            Given the assembly file name, looks up the XML documentation file name.
            Returns null if no XML documentation file is found.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.GetDocumentation(ICSharpCode.NRefactory.TypeSystem.IEntity)">
            <inheritdoc/>
        </member>
        <member name="M:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.GetDocumentation(System.String)">
            <summary>
            Get the documentation for the member with the specified documentation key.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.IndexEntry.HashCode">
            <summary>
            Hash code of the documentation tag
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Documentation.XmlDocumentationProvider.IndexEntry.PositionInFile">
            <summary>
            Position in the .xml file where the documentation starts
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Role">
            <summary>
            Represents the role a node plays within its parent.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Role.IsValid(System.Object)">
            <summary>
            Gets whether the specified node is valid in this role.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Role`1">
            <summary>
            Represents the role a node plays within its parent.
            All nodes with this role have type T.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Role`1.NullObject">
            <summary>
            Gets the null object used when there's no node with this role.
            Not every role has a null object; this property returns null for roles without a null object.
            </summary>
            <remarks>
            Roles used for non-collections should always have a null object, so that no AST property returns null.
            However, roles used for collections only may leave out the null object.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.AmbiguousTypeResolveResult">
            <summary>
            Represents an ambiguous type resolve result.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.TypeResolveResult">
            <summary>
            The resolved expression refers to a type name.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ResolveResult">
            <summary>
            Represents the result of resolving an expression.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.MemberResolveResult">
            <summary>
            Represents the result of a member invocation.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ArrayAccessResolveResult">
            <summary>
            Resolve result representing an array access.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ArrayCreateResolveResult">
            <summary>
            Resolve result representing an array creation.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ArrayCreateResolveResult.SizeArguments">
            <summary>
            Gets the size arguments.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ArrayCreateResolveResult.InitializerElements">
            <summary>
            Gets the initializer elements.
            This field may be null if no initializer was specified.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ByReferenceResolveResult">
            <summary>
            Represents the resolve result of an 'ref x' or 'out x' expression.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ConstantResolveResult">
            <summary>
            ResolveResult representing a compile-time constant.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ErrorResolveResult">
            <summary>
            Represents a resolve error.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.ErrorResolveResult.UnknownError">
            <summary>
            Gets an ErrorResolveResult instance with Type = SharedTypes.UnknownType.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.Conversion">
            <summary>
            Holds information about a conversion between two types.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.Conversion.None">
            <summary>
            Not a valid conversion.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.Conversion.IdentityConversion">
            <summary>
            Identity conversion.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.Conversion.ImplicitConstantExpressionConversion">
            <summary>
            The numeric conversion of a constant expression.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsValid">
            <summary>
            Gets whether the conversion is valid.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsLifted">
            <summary>
            Gets whether this conversion is a lifted version of another conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsDynamicConversion">
            <summary>
            Gets whether the conversion is dynamic.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsReferenceConversion">
            <summary>
            Gets whether the conversion is a reference conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsEnumerationConversion">
            <summary>
            Gets whether the conversion is an enumeration conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsNullableConversion">
            <summary>
            Gets whether the conversion is a nullable conversion
            (conversion between a nullable type and the regular type).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsUserDefined">
            <summary>
            Gets whether this conversion is user-defined (op_Implicit or op_Explicit).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsBoxingConversion">
            <summary>
            Gets whether this conversion is a boxing conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsUnboxingConversion">
            <summary>
            Gets whether this conversion is an unboxing conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsPointerConversion">
            <summary>
            Gets whether this conversion is an unboxing conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsMethodGroupConversion">
            <summary>
            Gets whether this conversion is a method group conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.IsAnonymousFunctionConversion">
            <summary>
            Gets whether this conversion is an anonymous function conversion.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.Conversion.Method">
            <summary>
            Gets the method associated with this conversion.
            For user-defined conversions, this is the method being called.
            For method-group conversions, this is the method that was chosen from the group.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.InvocationResolveResult">
            <summary>
            Represents the result of a method invocation.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Semantics.InvocationResolveResult.Arguments">
            <summary>
            Gets the arguments that are being passed to the method, in the order the arguments are being evaluated.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Semantics.InvocationResolveResult.GetArgumentsForCall">
            <summary>
            Gets the arguments in the order they are being passed to the method.
            For parameter arrays (params), this will return an ArrayCreateResolveResult.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.LocalResolveResult">
            <summary>
            Represents a local variable.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.NamespaceResolveResult">
            <summary>
            Represents that an expression resolved to a namespace.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.OperatorResolveResult">
            <summary>
            Represents a unary/binary/ternary operator invocation.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.OperatorResolveResult.OperatorType">
            <summary>
            Gets the operator type.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.OperatorResolveResult.Operands">
            <summary>
            Gets the operands.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.OperatorResolveResult.UserDefinedOperatorMethod">
            <summary>
            Gets the user defined operator method.
            Returns null if this is a predefined operator.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.OperatorResolveResult.IsLiftedOperator">
            <summary>
            Gets whether this is a lifted operator.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.ThisResolveResult">
            <summary>
            Represents the 'this' reference.
            Also used for the 'base' reference.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.TypeOfResolveResult">
            <summary>
            Represents the 'typeof'.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.TypeOfResolveResult.ReferencedType">
            <summary>
            The type referenced by the 'typeof'.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.UnknownMemberResolveResult">
            <summary>
            Represents an unknown member.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Semantics.UnknownMemberResolveResult.TargetType">
            <summary>
            The type on which the method is being called.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.UnknownMethodResolveResult">
            <summary>
            Represents an unknown method.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Semantics.UnknownIdentifierResolveResult">
            <summary>
            Represents an unknown identifier.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TextLocation">
            <summary>
            A line/column position.
            Text editor lines/columns are counted started from one.
            </summary>
            <remarks>
            The document provides the methods <see cref="M:ICSharpCode.NRefactory.Editor.IDocument.GetLocation(System.Int32)"/> and
            <see cref="M:ICSharpCode.NRefactory.Editor.IDocument.GetOffset(ICSharpCode.NRefactory.TextLocation)"/> to convert between offsets and TextLocations.
            </remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory.TextLocation.MinLine">
            <summary>
            Constant of the minimum line.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TextLocation.MinColumn">
            <summary>
            Constant of the minimum column.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TextLocation.Empty">
            <summary>
            Represents no text location (0, 0).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a TextLocation instance.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.ToString">
            <summary>
            Gets a string representation for debugging purposes.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.GetHashCode">
            <summary>
            Gets a hash code.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.Equals(System.Object)">
            <summary>
            Equality test.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.Equals(ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Equality test.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_Equality(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Equality test.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_Inequality(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Inequality test.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_LessThan(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_GreaterThan(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_LessThanOrEqual(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.op_GreaterThanOrEqual(ICSharpCode.NRefactory.TextLocation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TextLocation.CompareTo(ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Compares two text locations.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TextLocation.Line">
            <summary>
            Gets the line number.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TextLocation.Column">
            <summary>
            Gets the column number.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TextLocation.IsEmpty">
            <summary>
            Gets whether the TextLocation instance is empty.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Accessibility">
            <summary>
            Enum that describes the accessibility of an entity.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.None">
            <summary>
            The entity is completely inaccessible. This is used for C# explicit interface implementations.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Private">
            <summary>
            The entity is only accessible within the same class.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Public">
            <summary>
            The entity is accessible everywhere.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Protected">
            <summary>
            The entity is only accessible within the same class and in derived classes.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.Internal">
            <summary>
            The entity is accessible within the same project content.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.ProtectedOrInternal">
            <summary>
            The entity is accessible both everywhere in the project content, and in all derived classes.
            </summary>
            <remarks>This corresponds to C# 'protected internal'.</remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Accessibility.ProtectedAndInternal">
            <summary>
            The entity is accessible in derived classes within the same project content.
            </summary>
            <remarks>C# does not support this accessibility.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.Accessibility">
            <summary>
            Gets the accessibility of this entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsPrivate">
            <summary>
            Gets a value indicating whether this instance is private.
            </summary>
            <value>
            <c>true</c> if this instance is private; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsPublic">
            <summary>
            Gets a value indicating whether this instance is public.
            </summary>
            <value>
            <c>true</c> if this instance is public; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsProtected">
            <summary>
            Gets a value indicating whether this instance is protected.
            </summary>
            <value>
            <c>true</c> if this instance is protected; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsInternal">
            <summary>
            Gets a value indicating whether this instance is internal.
            </summary>
            <value>
            <c>true</c> if this instance is internal; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsProtectedOrInternal">
            <summary>
            Gets a value indicating whether this instance is protected or internal.
            </summary>
            <value>
            <c>true</c> if this instance is protected or internal; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IHasAccessibility.IsProtectedAndInternal">
            <summary>
            Gets a value indicating whether this instance is protected and internal.
            </summary>
            <value>
            <c>true</c> if this instance is protected and internal; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.AnonymousType">
            <summary>
            Anonymous type.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractType">
            <summary>
            Default implementation for IType interface.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IType">
            <summary>
            This interface represents a resolved type in the type system.
            </summary>
            <remarks>
            <para>
            A type is potentially
            - a type definition (<see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/>, i.e. a class, struct, interface, delegate, or built-in primitive type)
            - a parameterized type (<see cref="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedType"/>, e.g. List&lt;int&gt;)
            - a type parameter (<see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeParameter"/>, e.g. T)
            - an array (<see cref="T:ICSharpCode.NRefactory.TypeSystem.ArrayType"/>)
            - a pointer (<see cref="T:ICSharpCode.NRefactory.TypeSystem.PointerType"/>)
            - a managed reference (<see cref="T:ICSharpCode.NRefactory.TypeSystem.ByReferenceType"/>)
            - one of the special types (<see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnknownType"/>, <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.NullType"/>,
                 <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.Dynamic"/>, <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnboundTypeArgument"/>)
            
            The <see cref="P:ICSharpCode.NRefactory.TypeSystem.IType.Kind"/> property can be used to switch on the kind of a type.
            </para>
            <para>
            IType uses the null object pattern: <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnknownType"/> serves as the null object.
            Methods or properties returning IType never return null unless documented otherwise.
            </para>
            <para>
            Types should be compared for equality using the <see cref="M:System.IEquatable`1.Equals(`0)"/> method.
            Identical types do not necessarily use the same object reference.
            </para>
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamedElement.FullName">
            <summary>
            Gets the fully qualified name of the class the return type is pointing to.
            </summary>
            <returns>
            "System.Int32[]" for int[]<br/>
            "System.Collections.Generic.List" for List&lt;string&gt;
            "System.Environment.SpecialFolder" for Environment.SpecialFolder
            </returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamedElement.Name">
            <summary>
            Gets the short name of the class the return type is pointing to.
            </summary>
            <returns>
            "Int32[]" for int[]<br/>
            "List" for List&lt;string&gt;
            "SpecialFolder" for Environment.SpecialFolder
            </returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamedElement.ReflectionName">
            <summary>
            Gets the full reflection name of the element.
            </summary>
            <remarks>
            For types, the reflection name can be parsed back into a ITypeReference by using
            <see cref="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)"/>.
            </remarks>
            <returns>
            "System.Int32[]" for int[]<br/>
            "System.Int32[][,]" for C# int[,][]<br/>
            "System.Collections.Generic.List`1[[System.String]]" for List&lt;string&gt;
            "System.Environment+SpecialFolder" for Environment.SpecialFolder
            </returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamedElement.Namespace">
            <summary>
            Gets the full name of the namespace containing this entity.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetDefinition">
            <summary>
            Gets the underlying type definition.
            Can return null for types which do not have a type definition (for example arrays, pointers, type parameters).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.AcceptVisitor(ICSharpCode.NRefactory.TypeSystem.TypeVisitor)">
            <summary>
            Calls ITypeVisitor.Visit for this type.
            </summary>
            <returns>The return value of the ITypeVisitor.Visit call</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.VisitChildren(ICSharpCode.NRefactory.TypeSystem.TypeVisitor)">
            <summary>
            Calls ITypeVisitor.Visit for all children of this type, and reconstructs this type with the children based
            on the return values of the visit calls.
            </summary>
            <returns>A copy of this type, with all children replaced by the return value of the corresponding visitor call.
            If the visitor returned the original types for all children (or if there are no children), returns <c>this</c>.
            </returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.ToTypeReference">
            <summary>
            Creates a type reference that can be used to look up a type equivalent to this type in another compilation.
            </summary>
            <remarks>
            If this type is open, the resulting type reference will need to be looked up in an appropriate generic context.
            If this type is closed, the resulting type reference can be looked up in the main resolve context of another compilation.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetNestedTypes(System.Predicate{ICSharpCode.NRefactory.TypeSystem.ITypeDefinition},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets inner classes (including inherited inner classes).
            </summary>
            <param name="filter">The filter used to select which types to return.
            The filter is tested on the original type definitions (before parameterization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            <para>
            If the nested type is generic, this method will return a parameterized type,
            where the additional type parameters are set to <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnboundTypeArgument"/>.
            </para>
            <para>
            Type parameters belonging to the outer class will have the value copied from the outer type
            if it is a parameterized type. Otherwise, those existing type parameters will be self-parameterized,
            and thus 'leaked' to the caller in the same way the GetMembers() method does not specialize members
            from an <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/> and 'leaks' type parameters in member signatures.
            </para>
            </remarks>
            <example>
            <code>
            class Base&lt;T&gt; {
            	class Nested&lt;X&gt; {}
            }
            class Derived&lt;A, B&gt; : Base&lt;B&gt; {}
            
            Derived[string,int].GetNestedTypes() = { Base`1+Nested`1[int, unbound] }
            Derived.GetNestedTypes() = { Base`1+Nested`1[`1, unbound] }
            Base[`1].GetNestedTypes() = { Base`1+Nested`1[`1, unbound] }
            Base.GetNestedTypes() = { Base`1+Nested`1[`0, unbound] }
            </code>
            </example>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetNestedTypes(System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Predicate{ICSharpCode.NRefactory.TypeSystem.ITypeDefinition},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets inner classes (including inherited inner classes)
            that have <c>typeArguments.Count</c> additional type parameters.
            </summary>
            <param name="typeArguments">The type arguments passed to the inner class</param>
            <param name="filter">The filter used to select which types to return.
            The filter is tested on the original type definitions (before parameterization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            Type parameters belonging to the outer class will have the value copied from the outer type
            if it is a parameterized type. Otherwise, those existing type parameters will be self-parameterized,
            and thus 'leaked' to the caller in the same way the GetMembers() method does not specialize members
            from an <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/> and 'leaks' type parameters in member signatures.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetConstructors(System.Predicate{ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all instance constructors for this type.
            </summary>
            <param name="filter">The filter used to select which constructors to return.
            The filter is tested on the original method definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            <para>The result does not include constructors in base classes or static constructors.</para>
            <para>
            For methods on parameterized types, type substitution will be performed on the method signature,
            and the appropriate <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod"/> will be returned.
            </para>
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetMethods(System.Predicate{ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all methods that can be called on this type.
            </summary>
            <param name="filter">The filter used to select which methods to return.
            The filter is tested on the original method definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            <para>
            The result does not include constructors.
            </para>
            <para>
            For methods on parameterized types, type substitution will be performed on the method signature,
            and the appropriate <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod"/> will be returned.
            </para>
            <para>
            If the method being returned is generic, and this type is a parameterized type where the type
            arguments involve another method's type parameters, the resulting specialized signature
            will be ambiguous as to which method a type parameter belongs to.
            For example, "List[[``0]].GetMethods()" will return "ConvertAll(Converter`2[[``0, ``0]])".
            
            If possible, use the other GetMethods() overload to supply type arguments to the method,
            so that both class and method type parameter can be substituted at the same time, so that
            the ambiguity can be avoided.
            </para>
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetMethods(System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Predicate{ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all generic methods that can be called on this type with the specified type arguments.
            </summary>
            <param name="typeArguments">The type arguments used for the method call.</param>
            <param name="filter">The filter used to select which methods to return.
            The filter is tested on the original method definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            <para>The result does not include constructors.</para>
            <para>
            Type substitution will be performed on the method signature, creating a <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod"/>
            with the specified type arguments.
            </para>
            <para>
            When the list of type arguments is empty, this method acts like the GetMethods() overload without
            the type arguments parameter - that is, it also returns generic methods,
            and the other overload's remarks about ambiguous signatures apply here as well.
            </para>
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetProperties(System.Predicate{ICSharpCode.NRefactory.TypeSystem.IUnresolvedProperty},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all properties that can be called on this type.
            </summary>
            <param name="filter">The filter used to select which properties to return.
            The filter is tested on the original property definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            For properties on parameterized types, type substitution will be performed on the property signature,
            and the appropriate <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedProperty"/> will be returned.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetFields(System.Predicate{ICSharpCode.NRefactory.TypeSystem.IUnresolvedField},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all fields that can be accessed on this type.
            </summary>
            <param name="filter">The filter used to select which constructors to return.
            The filter is tested on the original field definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            For fields on parameterized types, type substitution will be performed on the field's return type,
            and the appropriate <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedField"/> will be returned.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetEvents(System.Predicate{ICSharpCode.NRefactory.TypeSystem.IUnresolvedEvent},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all events that can be accessed on this type.
            </summary>
            <param name="filter">The filter used to select which events to return.
            The filter is tested on the original event definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            For fields on parameterized types, type substitution will be performed on the event's return type,
            and the appropriate <see cref="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedEvent"/> will be returned.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IType.GetMembers(System.Predicate{ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)">
            <summary>
            Gets all members that can be called on this type.
            </summary>
            <param name="filter">The filter used to select which members to return.
            The filter is tested on the original member definitions (before specialization).</param>
            <param name="options">Specified additional options for the GetMembers() operation.</param>
            <remarks>
            <para>
            The resulting list is the union of GetFields(), GetProperties(), GetMethods() and GetEvents().
            It does not include constructors.
            For parameterized types, type substitution will be performed.
            </para>
            <para>
            For generic methods, the remarks about ambiguous signatures from the
            <see cref="M:ICSharpCode.NRefactory.TypeSystem.IType.GetMethods(System.Predicate{ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)"/> method apply here as well.
            </para>
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.Kind">
            <summary>
            Gets the type kind.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.IsReferenceType">
            <summary>
            Gets whether the type is a reference type or value type.
            </summary>
            <returns>
            true, if the type is a reference type.
            false, if the type is a value type.
            null, if the type is not known (e.g. unconstrained generic type parameter or type not found)
            </returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.DeclaringType">
            <summary>
            Gets the parent type, if this is a nested type.
            Returns null for top-level types.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.TypeParameterCount">
            <summary>
            Gets the number of type parameters.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IType.DirectBaseTypes">
            <summary>
            Gets the direct base types.
            </summary>
            <returns>Returns the direct base types including interfaces</returns>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ArrayType">
            <summary>
            Represents an array type.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ITypeReference">
            <summary>
            Represents a reference to a type.
            Must be resolved before it can be used as type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ITypeReference.Resolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves this type reference.
            </summary>
            <returns>
            Returns the resolved type.
            In case of an error, returns <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnknownType"/>.
            Never returns null.
            </returns>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning">
            <summary>
            Interface for TypeSystem objects that support interning.
            See <see cref="T:ICSharpCode.NRefactory.TypeSystem.IInterningProvider"/> for more information.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning.PrepareForInterning(ICSharpCode.NRefactory.TypeSystem.IInterningProvider)">
            <summary>
            Interns child objects and strings.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning.GetHashCodeForInterning">
            <summary>
            Gets a hash code for interning.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning.EqualsForInterning(ICSharpCode.NRefactory.TypeSystem.ISupportsInterning)">
            <summary>
            Equality test for interning.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.CecilLoader">
            <summary>
            Allows loading an IProjectContent from an already compiled assembly.
            </summary>
            <remarks>Instance methods are not thread-safe; you need to create multiple instances of CecilLoader
            if you want to load multiple project contents in parallel.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.NRefactory.TypeSystem.CecilLoader"/> class.
            </summary>
            <param name="createCecilReferences">
            If true references to the cecil objects are hold. In this case the cecil loader can do a type system -&gt; cecil mapping.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.LoadAssembly(Mono.Cecil.AssemblyDefinition)">
            <summary>
            Loads the assembly definition into a project content.
            </summary>
            <returns>IProjectContent that represents the assembly</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.LoadType(Mono.Cecil.TypeDefinition)">
            <summary>
            Loads a type from Cecil.
            </summary>
            <param name="typeDefinition">The Cecil TypeDefinition.</param>
            <returns>ITypeDefinition representing the Cecil type.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.CecilLoader.ReadTypeReference(Mono.Cecil.TypeReference,Mono.Cecil.ICustomAttributeProvider)">
            <summary>
            Reads a type reference.
            </summary>
            <param name="type">The Cecil type reference that should be converted into
            a type system type reference.</param>
            <param name="typeAttributes">Attributes associated with the Cecil type reference.
            This is used to support the 'dynamic' type.</param>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.IncludeInternalMembers">
            <summary>
            Specifies whether to include internal members. The default is false.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.DocumentationProvider">
            <summary>
            Gets/Sets the documentation provider that is used to retrieve the XML documentation for all members.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.InterningProvider">
            <summary>
            Gets/Sets the interning provider.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.CancellationToken">
            <summary>
            Gets/Sets the cancellation token used by the cecil loader.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.CecilLoader.HasCecilReferences">
            <summary>
            Gets a value indicating whether this instance stores references to the cecil objects.
            </summary>
            <value>
            <c>true</c> if this instance has references to the cecil objects; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedAssembly">
            <summary>
            Default implementation for <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAssembly"/>.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IFreezable.Freeze">
            <summary>
            Freezes this instance.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IFreezable.IsFrozen">
            <summary>
            Gets if this instance is frozen. Frozen instances are immutable and thus thread-safe.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractFreezable.Freeze">
            <summary>
            Freezes this instance.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractFreezable.IsFrozen">
            <summary>
            Gets if this instance is frozen. Frozen instances are immutable and thus thread-safe.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAssembly">
            <summary>
            Represents an unresolved assembly.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IAssemblyReference.Resolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves this assembly.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAssembly.AssemblyName">
            <summary>
            Gets the assembly name (short name).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAssembly.AssemblyAttributes">
            <summary>
            Gets the list of all assembly attributes in the project.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAssembly.ModuleAttributes">
            <summary>
            Gets the list of all module attributes in the project.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAssembly.TopLevelTypeDefinitions">
            <summary>
            Gets all non-nested types in the assembly.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedAssembly.AddTypeDefinition(ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeDefinition)">
            <summary>
            Adds a new top-level type definition to this assembly.
            </summary>
            <remarks>DefaultUnresolvedAssembly does not support partial classes.
            Adding more than one part of a type will cause an ArgumentException.</remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IAssembly">
            <summary>
            Represents an assembly.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IAssembly.InternalsVisibleTo(ICSharpCode.NRefactory.TypeSystem.IAssembly)">
            <summary>
            Gets whether the internals of this assembly are visible in the specified assembly.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IAssembly.GetTypeDefinition(System.String,System.String,System.Int32)">
            <summary>
            Gets the type definition for a top-level type.
            </summary>
            <remarks>This method uses ordinal name comparison, not the compilation's name comparer.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IAssembly.GetTypeDefinition(ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeDefinition)">
            <summary>
            Gets the type definition for the specified unresolved type.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAssembly.UnresolvedAssembly">
            <summary>
            Gets the original unresolved assembly.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAssembly.IsMainAssembly">
            <summary>
            Gets whether this assembly is the main assembly of the compilation.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAssembly.AssemblyName">
            <summary>
            Gets the assembly name (short name).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAssembly.AssemblyAttributes">
            <summary>
            Gets the list of all assembly attributes in the project.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAssembly.ModuleAttributes">
            <summary>
            Gets the list of all module attributes in the project.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAssembly.RootNamespace">
            <summary>
            Gets the root namespace for this assembly.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAssembly.TopLevelTypeDefinitions">
            <summary>
            Gets all non-nested types in the assembly.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.INamespace">
            <summary>
            Represents a resolved namespace.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.INamespace.GetChildNamespace(System.String)">
            <summary>
            Gets a direct child namespace by its short name.
            Returns null when the namespace cannot be found.
            </summary>
            <remarks>
            This method uses the compilation's current string comparer.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.INamespace.GetTypeDefinition(System.String,System.Int32)">
            <summary>
            Gets the type with the specified short name and type parameter count.
            Returns null if the type cannot be found.
            </summary>
            <remarks>
            This method uses the compilation's current string comparer.
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamespace.ExternAlias">
            <summary>
            Gets the extern alias for this namespace.
            Returns an empty string for normal namespaces.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamespace.FullName">
            <summary>
            Gets the full name of this namespace. (e.g. "System.Collections")
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamespace.Name">
            <summary>
            Gets the short name of this namespace (e.g. "Collections").
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamespace.ParentNamespace">
            <summary>
            Gets the parent namespace.
            Returns null if this is the root namespace.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamespace.ChildNamespaces">
            <summary>
            Gets the child namespaces in this namespace.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.INamespace.Types">
            <summary>
            Gets the types in this namespace.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IConstantValue">
            <summary>
            Represents an unresolved constant value.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IConstantValue.Resolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves the value of this constant.
            </summary>
            <param name="context">Context where the constant value will be used.</param>
            <returns>Resolve result representing the constant value.
            This method never returns null; in case of errors, an ErrorResolveResult will be returned.</returns>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAttribute">
            <summary>
            Represents an unresolved attribute.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAttribute.CreateResolvedAttribute(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves the attribute.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAttribute.Region">
            <summary>
            Gets the code region of this attribute.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IAttribute">
            <summary>
            Represents an attribute.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAttribute.Region">
            <summary>
            Gets the code region of this attribute.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAttribute.AttributeType">
            <summary>
            Gets the type of the attribute.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAttribute.Constructor">
            <summary>
            Gets the constructor being used.
            This property may return null if no matching constructor was found.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAttribute.PositionalArguments">
            <summary>
            Gets the positional arguments.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IAttribute.NamedArguments">
            <summary>
            Gets the named arguments passed to the attribute.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.DomRegion.IsInside(System.Int32,System.Int32)">
            <remarks>
            Returns true, if the given coordinates (line, column) are in the region.
            This method assumes that for an unknown end the end line is == -1
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.DomRegion.EndLine">
            <value>
            if the end line is == -1 the end column is -1 too
            this stands for an unknwon end
            </value>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.DomRegion.EndColumn">
            <value>
            if the end column is == -1 the end line is -1 too
            this stands for an unknown end
            </value>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods">
            <summary>
            Contains extension methods for the type system.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.GetAllBaseTypes(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets all base types.
            </summary>
            <remarks>This is the reflexive and transitive closure of <see cref="P:ICSharpCode.NRefactory.TypeSystem.IType.DirectBaseTypes"/>.
            Note that this method does not return all supertypes - doing so is impossible due to contravariance
            (and undesirable for covariance as the list could become very large).
            
            The output is ordered so that base types occur before derived types.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.GetNonInterfaceBaseTypes(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets all non-interface base types.
            </summary>
            <remarks>
            When <paramref name="type"/> is an interface, this method will also return base interfaces (return same output as GetAllBaseTypes()).
            
            The output is ordered so that base types occur before derived types.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.GetAllBaseTypeDefinitions(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets all base type definitions.
            </summary>
            <remarks>
            This is equivalent to type.GetAllBaseTypes().Select(t => t.GetDefinition()).Where(d => d != null).Distinct().
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.IsDerivedFrom(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition,ICSharpCode.NRefactory.TypeSystem.ITypeDefinition)">
            <summary>
            Gets whether this type definition is derived from the base type defintiion.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.IsOpen(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets whether the type is an open type (contains type parameters).
            </summary>
            <example>
            <code>
            class X&lt;T&gt; {
              List&lt;T&gt; open;
              X&lt;X&lt;T[]&gt;&gt; open;
              X&lt;string&gt; closed;
              int closed;
            }
            </code>
            </example>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.IsUnbound(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets whether the type is unbound (is a generic type, but no type arguments were provided).
            </summary>
            <remarks>
            In "<c>typeof(List&lt;Dictionary&lt;,&gt;&gt;)</c>", only the Dictionary is unbound, the List is considered
            bound despite containing an unbound type.
            This method returns false for partially parameterized types (<c>Dictionary&lt;string, &gt;</c>).
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.Import(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Imports a type from another compilation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.Import(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.ITypeDefinition)">
            <summary>
            Imports a type from another compilation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.Import(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IMember)">
            <summary>
            Imports a member from another compilation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.Import(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IMethod)">
            <summary>
            Imports a member from another compilation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.Import(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IField)">
            <summary>
            Imports a member from another compilation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.Import(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IEvent)">
            <summary>
            Imports a member from another compilation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.Import(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IProperty)">
            <summary>
            Imports a member from another compilation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.GetDelegateInvokeMethod(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets the invoke method for a delegate type.
            </summary>
            <remarks>
            Returns null if the type is not a delegate type; or if the invoke method could not be found.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.GetInnermostTypeDefinition(ICSharpCode.NRefactory.TypeSystem.IParsedFile,System.Int32,System.Int32)">
            <summary>
            Gets the type (potentially a nested type) defined at the specified location.
            Returns null if no type is defined at that location.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.GetMember(ICSharpCode.NRefactory.TypeSystem.IParsedFile,System.Int32,System.Int32)">
            <summary>
            Gets the member defined at the specified location.
            Returns null if no member is defined at that location.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ExtensionMethods.GetSubTypeDefinitions(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition)">
            <summary>
            Gets all sub type definitions defined in a context.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.TypeVisitor">
            <summary>
            Base class for the visitor pattern on <see cref="T:ICSharpCode.NRefactory.TypeSystem.IType"/>.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.None">
            <summary>
            Convert only the name.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.ShowParameterList">
            <summary>
            Show the parameter list
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.ShowParameterNames">
            <summary>
            Show names for parameters
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.ShowAccessibility">
            <summary>
            Show the accessibility (private, public, etc.)
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.ShowDefinitionKeyWord">
            <summary>
            Show the definition key word (class, struct, Sub, Function, etc.)
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.UseFullyQualifiedMemberNames">
            <summary>
            Show the fully qualified name for the member
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.ShowModifiers">
            <summary>
            Show modifiers (virtual, override, etc.)
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.ShowReturnType">
            <summary>
            Show the return type
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.UseFullyQualifiedTypeNames">
            <summary>
            Use fully qualified names for return type and parameters.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.ShowTypeParameterList">
            <summary>
            Show the list of type parameters on method and class declarations.
            Type arguments for parameter/return types are always shown.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.ConversionFlags.ShowBody">
            <summary>
            For fields, events and methods: adds a semicolon at the end.
            For properties: shows "{ get; }" or similar.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ICompilation.GetNamespaceForExternAlias(System.String)">
            <summary>
            Gets the root namespace for a given extern alias.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ICompilation.MainAssembly">
            <summary>
            Gets the current assembly.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ICompilation.TypeResolveContext">
            <summary>
            Gets the type resolve context that specifies this compilation and no current assembly or entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ICompilation.ReferencedAssemblies">
            <summary>
            Gets the referenced assemblies.
            This list does not include the current assembly.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ICompilation.RootNamespace">
            <summary>
            Gets the root namespace of this compilation.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ICompilation.NameComparer">
            <summary>
            Gets the name comparer for the language being compiled.
            This is the string comparer used for the INamespace.GetTypeDefinition method.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity">
            <summary>
            Represents an unresolved entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.EntityType">
            <summary>
            Gets the entity type.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.Region">
            <summary>
            Gets the complete entity region (including header+body)
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.BodyRegion">
            <summary>
            Gets the entity body region.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.DeclaringTypeDefinition">
            <summary>
            Gets the declaring class.
            For members, this is the class that contains the member.
            For nested classes, this is the outer class. For top-level entities, this property returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.ParsedFile">
            <summary>
            Gets the parsed file in which this entity is defined.
            Returns null if this entity wasn't parsed from source code (e.g. loaded from a .dll with CecilLoader).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.Attributes">
            <summary>
            Gets the attributes on this entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.IsStatic">
            <summary>
            Gets whether this entity is static.
            Returns true if either the 'static' or the 'const' modifier is set.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.IsAbstract">
            <summary>
            Returns whether this entity is abstract.
            </summary>
            <remarks>Static classes also count as abstract classes.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.IsSealed">
            <summary>
            Returns whether this entity is sealed.
            </summary>
            <remarks>Static classes also count as sealed classes.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.IsShadowing">
            <summary>
            Gets whether this member is declared to be shadowing another member with the same name.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity.IsSynthetic">
            <summary>
            Gets whether this member is generated by a macro/compiler feature.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IEntity">
            <summary>
            Represents a resolved entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.EntityType">
            <summary>
            Gets the entity type.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.Region">
            <summary>
            Gets the complete entity region (including header+body)
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.BodyRegion">
            <summary>
            Gets the entity body region.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.DeclaringTypeDefinition">
            <summary>
            Gets the declaring class.
            For members, this is the class that contains the member.
            For nested classes, this is the outer class. For top-level entities, this property returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.DeclaringType">
            <summary>
            Gets/Sets the declaring type (incl. type arguments, if any).
            This property never returns null -- for top-level entities, it returns SharedTypes.UnknownType.
            If this is not a specialized member, the value returned is equal to <see cref="P:ICSharpCode.NRefactory.TypeSystem.IEntity.DeclaringTypeDefinition"/>.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.ParentAssembly">
            <summary>
            The assembly in which this entity is defined.
            This property never returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.Attributes">
            <summary>
            Gets the attributes on this entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.Documentation">
            <summary>
            Gets the documentation for this entity.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsStatic">
            <summary>
            Gets whether this entity is static.
            Returns true if either the 'static' or the 'const' modifier is set.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsAbstract">
            <summary>
            Returns whether this entity is abstract.
            </summary>
            <remarks>Static classes also count as abstract classes.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsSealed">
            <summary>
            Returns whether this entity is sealed.
            </summary>
            <remarks>Static classes also count as sealed classes.</remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsShadowing">
            <summary>
            Gets whether this member is declared to be shadowing another member with the same name.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IEntity.IsSynthetic">
            <summary>
            Gets whether this member is generated by a macro/compiler feature.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember">
            <summary>
            Method/field/property/event.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember.ReturnType">
            <summary>
            Gets the return type of this member.
            This property never returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember.IsExplicitInterfaceImplementation">
            <summary>
            Gets whether this member is explicitly implementing an interface.
            If this property is true, the member can only be called through the interfaces it implements.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember.ExplicitInterfaceImplementations">
            <summary>
            Gets the interfaces that are explicitly implemented by this member.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember.IsVirtual">
            <summary>
            Gets if the member is virtual. Is true only if the "virtual" modifier was used, but non-virtual
            members can be overridden, too; if they are abstract or overriding a method.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember.IsOverride">
            <summary>
            Gets whether this member is overriding another member.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember.IsOverridable">
            <summary>
            Gets if the member can be overridden. Returns true when the member is "abstract", "virtual" or "override" but not "sealed".
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IMember">
            <summary>
            Method/field/property/event.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IMember.ToMemberReference">
            <summary>
            Creates a member reference that can be used to rediscover this member in another compilation.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.MemberDefinition">
            <summary>
            Gets the original member definition for this member.
            Returns <c>this</c> if this is not a specialized member.
            Specialized members are the result of overload resolution with type substitution.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.UnresolvedMember">
            <summary>
            Gets the unresolved member instance from which this member was created.
            This property may return <c>null</c> for special members that do not have a corresponding unresolved member instance.
            </summary>
            <remarks>
            For specialized members, this property returns the unresolved member for the original member definition.
            For partial methods, this property returns the implementing partial method declaration, if one exists, and the
            defining partial method declaration otherwise.
            For the members used to represent the built-in C# operators like "operator +(int, int);", this property returns <c>null</c>.
            </remarks>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.ReturnType">
            <summary>
            Gets the return type of this member.
            This property never returns <c>null</c>.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.InterfaceImplementations">
            <summary>
            Gets the interface members implemented by this member (both implicitly and explicitly).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.IsExplicitInterfaceImplementation">
            <summary>
            Gets whether this member is explicitly implementing an interface.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.IsVirtual">
            <summary>
            Gets if the member is virtual. Is true only if the "virtual" modifier was used, but non-virtual
            members can be overridden, too; if they are abstract or overriding a method.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.IsOverride">
            <summary>
            Gets whether this member is overriding another member.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMember.IsOverridable">
            <summary>
            Gets if the member can be overridden. Returns true when the member is "abstract", "virtual" or "override" but not "sealed".
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedField">
            <summary>
            Represents a field or constant.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedField.IsReadOnly">
            <summary>
            Gets whether this field is readonly.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedField.IsVolatile">
            <summary>
            Gets whether this field is volatile.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedField.IsConst">
            <summary>
            Gets whether this field is a constant (C#-like const).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IField">
            <summary>
            Represents a field or constant.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IVariable">
            <summary>
            Represents a variable (name/type pair).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.Name">
            <summary>
            Gets the name of the variable.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.Region">
            <summary>
            Gets the declaration region of the variable.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.Type">
            <summary>
            Gets the type of the variable.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.IsConst">
            <summary>
            Gets whether this variable is a constant (C#-like const).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IVariable.ConstantValue">
            <summary>
            If this field is a constant, retrieves the value.
            For parameters, this is the default value.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IField.Name">
            <summary>
            Gets the name of the field.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IField.Region">
            <summary>
            Gets the region where the field is declared.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IField.IsReadOnly">
            <summary>
            Gets whether this field is readonly.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IField.IsVolatile">
            <summary>
            Gets whether this field is volatile.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IInterningProvider">
            <summary>
            Provider used for interning.
            </summary>
            <remarks>
            A simple IInterningProvider implementation could use 3 dictionaries:
             1. using value equality comparer (for certain types known to implement value equality, e.g. string and IType)
             2. using comparer that calls into ISupportsInterning (for types implementing ISupportsInterning)
             3. list comparer (for InternList method)
            
            On the first Intern()-call, the provider tells the object to prepare for interning (ISupportsInterning.PrepareForInterning)
            and stores it into a dictionary. On further Intern() calls, the original object is returned for all equal objects.
            This allows reducing the memory usage by using a single object instance where possible.
            
            Interning provider implementations could also use the interning logic for different purposes:
            for example, it could be used to determine which objects are used jointly between multiple type definitions
            and which are used only within a single type definition. Then a persistent file format could be organized so
            that shared objects are loaded only once, yet non-shared objects get loaded lazily together with the class.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IInterningProvider.Intern``1(``0)">
            <summary>
            Interns the specified object.
            The object must implement <see cref="T:ICSharpCode.NRefactory.TypeSystem.ISupportsInterning"/>, or must be of one of the types
            known to the interning provider to use value equality,
            otherwise it will be returned without being interned.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IMemberReference.Resolve(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Resolves the member.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameterizedMember">
            <summary>
            Represents a method or property.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod.ReturnTypeAttributes">
            <summary>
            Gets the attributes associated with the return type. (e.g. [return: MarshalAs(...)])
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IMethod">
            <summary>
            Represents a method, constructor, destructor or operator.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IParameterizedMember">
            <summary>
            Represents a method or property.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IMethod.ReturnTypeAttributes">
            <summary>
            Gets the attributes associated with the return type. (e.g. [return: MarshalAs(...)])
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractResolvedEntity">
            <summary>
            Implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IEntity"/> that resolves an unresolved entity.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractResolvedMember">
            <summary>
            Implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IMember"/> that resolves an unresolved member.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ITypeParameter">
            <summary>
            Type parameter of a generic class/method.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.OwnerType">
            <summary>
            Get the type of this type parameter's owner.
            </summary>
            <returns>EntityType.TypeDefinition or EntityType.Method</returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Owner">
            <summary>
            Gets the owning method/class.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Index">
            <summary>
            Gets the index of the type parameter in the type parameter list of the owning method/class.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Attributes">
            <summary>
            Gets the list of attributes declared on this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Variance">
            <summary>
            Gets the variance of this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.Region">
            <summary>
            Gets the region where the type parameter is defined.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.EffectiveBaseClass">
            <summary>
            Gets the effective base class of this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.EffectiveInterfaceSet">
            <summary>
            Gets the effective interface set of this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.HasDefaultConstructorConstraint">
            <summary>
            Gets if the type parameter has the 'new()' constraint.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.HasReferenceTypeConstraint">
            <summary>
            Gets if the type parameter has the 'class' constraint.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeParameter.HasValueTypeConstraint">
            <summary>
            Gets if the type parameter has the 'struct' constraint.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractUnresolvedEntity">
            <summary>
            Base class for <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEntity"/> implementations.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.AbstractUnresolvedMember">
            <summary>
            Base class for <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMember"/> implementations.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.BaseTypeCollector">
            <summary>
            Helper class for the GetAllBaseTypes() implementation.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.Implementation.BaseTypeCollector.SkipImplementedInterfaces">
            <summary>
            If this option is enabled, the list will not contain interfaces when retrieving the base types
            of a class.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultAssemblyReference">
            <summary>
            References an existing assembly by name.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultMemberReference">
            <summary>
            References an entity by its type and name.
            This class can be used to refer to fields, events, and parameterless properties.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultParameter">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IParameter"/>.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.Attributes">
            <summary>
            Gets the list of attributes.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.IsRef">
            <summary>
            Gets whether this parameter is a C# 'ref' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.IsOut">
            <summary>
            Gets whether this parameter is a C# 'out' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.IsParams">
            <summary>
            Gets whether this parameter is a C# 'params' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParameter.IsOptional">
            <summary>
            Gets whether this parameter is optional.
            The default value is given by the <see cref="P:ICSharpCode.NRefactory.TypeSystem.IVariable.ConstantValue"/> property.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultResolvedMethod">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IMethod"/> that resolves an unresolved method.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IProperty">
            <summary>
            Represents a property or indexer.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultResolvedTypeDefinition">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition">
            <summary>
            Represents a class, enum, interface, struct, delegate or VB module.
            For partial classes, this represents the whole class.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.Parts">
            <summary>
            Returns all parts that contribute to this type definition.
            Non-partial classes have a single part that represents the whole class.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.KnownTypeCode">
            <summary>
            Gets the known type code for this type definition.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.EnumUnderlyingType">
            <summary>
            For enums: returns the underlying primitive type.
            For all other types: returns <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnknownType"/>.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.DeclaringType">
            <summary>
            Gets/Sets the declaring type (incl. type arguments, if any).
            This property never returns null -- for top-level entities, it returns SharedTypes.UnknownType.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition.HasExtensionMethods">
            <summary>
            Gets whether this type contains extension methods.
            </summary>
            <remarks>This property is used to speed up the search for extension methods.</remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultSolutionSnapshot">
            <summary>
            Default implementation of ISolutionSnapshot.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ISolutionSnapshot">
            <summary>
            Represents a snapshot of the whole solution (multiple compilations).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ISolutionSnapshot.GetCompilation(ICSharpCode.NRefactory.TypeSystem.IProjectContent)">
            <summary>
            Gets the compilation for the specified project.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedAttribute">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedAttribute"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedEvent">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedEvent"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedField">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedField"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedMethod">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedMethod"/> interface.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedParameter">
            <summary>
            Default implementation for IUnresolvedParameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameter.Name">
            <summary>
            Gets the name of the variable.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameter.Region">
            <summary>
            Gets the declaration region of the variable.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameter.Type">
            <summary>
            Gets the type of the variable.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameter.Attributes">
            <summary>
            Gets the list of attributes.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameter.IsRef">
            <summary>
            Gets whether this parameter is a C# 'ref' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameter.IsOut">
            <summary>
            Gets whether this parameter is a C# 'out' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameter.IsParams">
            <summary>
            Gets whether this parameter is a C# 'params' parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedParameter.IsOptional">
            <summary>
            Gets whether this parameter is optional.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedProperty">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedProperty"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedProperty">
            <summary>
            Represents a property or indexer.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedTypeDefinition">
            <summary>
            Represents an unresolved type definition.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeDefinition">
            <summary>
            Represents an unresolved class, enum, interface, struct, delegate or VB module.
            For partial classes, an unresolved type definition represents only a single part.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeDefinition.CreateResolveContext(ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext)">
            <summary>
            Creates a type resolve context for this part of the type definition.
            This method is used to add language-specific elements like the C# UsingScope
            to the type resolve context.
            </summary>
            <param name="parentContext">The parent context (e.g. the parent assembly),
            including the parent </param>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeDefinition.HasExtensionMethods">
            <summary>
            Gets whether the type definition contains extension methods.
            Returns null when the type definition needs to be resolved in order to determine whether
            methods are extension methods.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.DefaultUnresolvedTypeParameter">
            <summary>
            Default implementation of <see cref="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeParameter"/>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeParameter">
            <summary>
            Type parameter of a generic class/method.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeParameter.OwnerType">
            <summary>
            Get the type of this type parameter's owner.
            </summary>
            <returns>EntityType.TypeDefinition or EntityType.Method</returns>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeParameter.Index">
            <summary>
            Gets the index of the type parameter in the type parameter list of the owning method/class.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeParameter.Attributes">
            <summary>
            Gets the list of attributes declared on this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeParameter.Variance">
            <summary>
            Gets the variance of this type parameter.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IUnresolvedTypeParameter.Region">
            <summary>
            Gets the region where the type parameter is defined.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference">
            <summary>
            Type Reference used when the fully qualified type name is known.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.GetClassTypeReference.#ctor(ICSharpCode.NRefactory.TypeSystem.IAssemblyReference,System.String,System.String,System.Int32)">
            <summary>
            Creates a new GetClassTypeReference that searches a type in the specified assembly.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.GetMembersHelper">
            <summary>
            Provides helper methods for implementing GetMembers() on IType-implementations.
            Note: GetMembersHelper will recursively call back into IType.GetMembers(), but only with
            both GetMemberOptions.IgnoreInheritedMembers and GetMemberOptions.ReturnMemberDefinitions set,
            and only the 'simple' overloads (not taking type arguments).
            
            Ensure that your IType implementation does not use the GetMembersHelper if both flags are set,
            otherwise you'll get a StackOverflowException!
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.KnownTypeCache">
            <summary>
            Cache for KnownTypeReferences.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.MergedNamespace">
            <summary>
            A merged namespace.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.MergedNamespace.#ctor(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.INamespace[],System.String)">
            <summary>
            Creates a new merged root namespace.
            </summary>
            <param name="compilation">The main compilation.</param>
            <param name="namespaces">The individual namespaces being merged.</param>
            <param name="externAlias">The extern alias for this namespace.</param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.MergedNamespace.#ctor(ICSharpCode.NRefactory.TypeSystem.INamespace,ICSharpCode.NRefactory.TypeSystem.INamespace[])">
            <summary>
            Creates a new merged child namespace.
            </summary>
            <param name="parentNamespace">The parent merged namespace.</param>
            <param name="namespaces">The individual namespaces being merged.</param>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.MinimalCorlib">
            <summary>
            Resolve context represents the minimal mscorlib required for evaluating constants.
            This contains all known types (<see cref="T:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode"/>) and no other types.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.NestedTypeReference">
            <summary>
            Type reference used to reference nested types.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.NestedTypeReference.#ctor(ICSharpCode.NRefactory.TypeSystem.ITypeReference,System.String,System.Int32)">
            <summary>
            Creates a new NestedTypeReference.
            </summary>
            <param name="declaringTypeRef">Reference to the declaring type.</param>
            <param name="name">Name of the nested class</param>
            <param name="additionalTypeParameterCount">Number of type parameters on the inner class (without type parameters on baseTypeRef)</param>
            <remarks>
            <paramref name="declaringTypeRef"/> must be exactly the (unbound) declaring type, not a derived type, not a parameterized type.
            NestedTypeReference thus always resolves to a type definition, never to (partially) parameterized types.
            </remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleCompilation">
            <summary>
            Simple compilation implementation.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleConstantValue">
            <summary>
            A simple constant value that is independent of the resolve context.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleInterningProvider">
            <summary>
            Simple interning provider.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SimpleTypeResolveContext">
            <summary>
            Default ITypeResolveContext implementation.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.Compilation">
            <summary>
            Gets the parent compilation.
            This property never returns null.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.CurrentAssembly">
            <summary>
            Gets the current assembly.
            This property may return null if this context does not specify any assembly.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.CurrentTypeDefinition">
            <summary>
            Gets the current type definition.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.ITypeResolveContext.CurrentMember">
            <summary>
            Gets the current member.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedEvent">
            <summary>
            Represents a specialized IEvent (event after type substitution).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMember">
            <summary>
            Represents a SpecializedMember (a member on which type substitution has been performed).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedField">
            <summary>
            Represents a specialized IField (field after type substitution).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod">
            <summary>
            Represents a specialized IMethod (e.g. after type substitution).
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedMethod.TypeArguments">
            <summary>
            Gets the type arguments passed to this method.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.SpecializedProperty">
            <summary>
            Represents a specialized IProperty (property after type substitution).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeParameterSubstitution">
            <summary>
            Substitues class and method type parameters.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.TypeParameterSubstitution.#ctor(System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType},System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType})">
            <summary>
            Creates a new type parameter substitution.
            </summary>
            <param name="classTypeArguments">
            The type arguments to substitute for class type parameters.
            Pass <c>null</c> to keep class type parameters unmodified.
            </param>
            <param name="methodTypeArguments">
            The type arguments to substitute for method type parameters.
            Pass <c>null</c> to keep method type parameters unmodified.
            </param>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.UnknownType">
            <summary>
            An unknown type where (part) of the name is known.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Implementation.UnknownType.#ctor(System.String,System.String,System.Int32)">
            <summary>
            Creates a new unknown type.
            </summary>
            <param name="namespaceName">Namespace name, if known. Can be null if unknown.</param>
            <param name="name">Name of the type, must not be null.</param>
            <param name="typeParameterCount">Type parameter count, zero if unknown.</param>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Implementation.VoidTypeDefinition">
            <summary>
            Special type definition for 'void'.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.InheritanceHelper">
            <summary>
            Provides helper methods for inheritance.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.InheritanceHelper.GetBaseMember(ICSharpCode.NRefactory.TypeSystem.IMember)">
            <summary>
            Gets the base member that has the same signature.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.InheritanceHelper.GetBaseMembers(ICSharpCode.NRefactory.TypeSystem.IMember,System.Boolean)">
            <summary>
            Gets all base members that have the same signature.
            </summary>
            <returns>
            List of base members with the same signature. The member from the derived-most base class is returned first.
            </returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.InheritanceHelper.GetDerivedMember(ICSharpCode.NRefactory.TypeSystem.IMember,ICSharpCode.NRefactory.TypeSystem.ITypeDefinition)">
            <summary>
            Finds the member declared in 'derivedType' that has the same signature (could override) 'baseMember'.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IntersectionType">
            <summary>
            Represents the intersection of several types.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IParsedFile">
            <summary>
            Represents a single file that was parsed.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IParsedFile.GetTopLevelTypeDefinition(ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Gets the top-level type defined at the specified location.
            Returns null if no type is defined at that location.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IParsedFile.GetInnermostTypeDefinition(ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Gets the type (potentially a nested type) defined at the specified location.
            Returns null if no type is defined at that location.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IParsedFile.GetMember(ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Gets the member defined at the specified location.
            Returns null if no member is defined at that location.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IParsedFile.GetTypeResolveContext(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Gets a type resolve context at a given location.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParsedFile.FileName">
            <summary>
            Returns the full path of the file.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParsedFile.LastWriteTime">
            <summary>
            Gets the time when the file was last written.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParsedFile.TopLevelTypeDefinitions">
            <summary>
            Gets all top-level type definitions.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParsedFile.AssemblyAttributes">
            <summary>
            Gets all assembly attributes that are defined in this file.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParsedFile.ModuleAttributes">
            <summary>
            Gets all module attributes that are defined in this file.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IParsedFile.Errors">
            <summary>
            Gets the parser errors.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.IProjectContent">
            <summary>
            Represents an assembly consisting of source code (parsed files).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.GetFile(System.String)">
            <summary>
            Gets a parsed file by its file name.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.CreateCompilation">
            <summary>
            Creates a new <see cref="T:ICSharpCode.NRefactory.TypeSystem.ICompilation"/> that allows resolving within this project.
            </summary>
            <remarks>
            An ICompilation is immutable, it operates on a snapshot of this project.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.CreateCompilation(ICSharpCode.NRefactory.TypeSystem.ISolutionSnapshot)">
            <summary>
            Creates a new <see cref="T:ICSharpCode.NRefactory.TypeSystem.ICompilation"/> that allows resolving within this project.
            </summary>
            <param name="solutionSnapshot">The parent solution snapshot to use for the compilation.</param>
            <remarks>
            An ICompilation is immutable, it operates on a snapshot of this project.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.SetAssemblyName(System.String)">
            <summary>
            Changes the assembly name of this project content.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.AddAssemblyReferences(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IAssemblyReference})">
            <summary>
            Add assembly references to this project content.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.RemoveAssemblyReferences(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IAssemblyReference})">
            <summary>
            Removes assembly references from this project content.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.UpdateProjectContent(ICSharpCode.NRefactory.TypeSystem.IParsedFile,ICSharpCode.NRefactory.TypeSystem.IParsedFile)">
            <summary>
            Removes types and attributes from oldFile from the project, and adds those from newFile.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.IProjectContent.UpdateProjectContent(System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IParsedFile},System.Collections.Generic.IEnumerable{ICSharpCode.NRefactory.TypeSystem.IParsedFile})">
            <summary>
            Removes types and attributes from oldFiles from the project, and adds those from newFiles.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IProjectContent.Files">
            <summary>
            Gets the list of all parsed files in the project content.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.IProjectContent.AssemblyReferences">
            <summary>
            Gets the referenced assemblies.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.GetMemberOptions.None">
            <summary>
            No options specified - this is the default.
            Members will be specialized, and inherited members will be included.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.GetMemberOptions.ReturnMemberDefinitions">
            <summary>
            Do not specialize the returned members - directly return the definitions.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.GetMemberOptions.IgnoreInheritedMembers">
            <summary>
            Do not list inherited members - only list members defined directly on this type.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.VarianceModifier">
            <summary>
            Represents the variance of a type parameter.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.VarianceModifier.Invariant">
            <summary>
            The type parameter is not variant.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.VarianceModifier.Covariant">
            <summary>
            The type parameter is covariant (used in output position).
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.VarianceModifier.Contravariant">
            <summary>
            The type parameter is contravariant (used in input position).
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode">
            <summary>
            Represents some well-known types.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.None">
            <summary>
            Not one of the known types.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Object">
            <summary><c>object</c> (System.Object)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.DBNull">
            <summary><c>System.DBNull</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Boolean">
            <summary><c>bool</c> (System.Boolean)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Char">
            <summary><c>char</c> (System.Char)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.SByte">
            <summary><c>sbyte</c> (System.SByte)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Byte">
            <summary><c>byte</c> (System.Byte)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Int16">
            <summary><c>short</c> (System.Int16)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.UInt16">
            <summary><c>ushort</c> (System.UInt16)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Int32">
            <summary><c>int</c> (System.Int32)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.UInt32">
            <summary><c>uint</c> (System.UInt32)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Int64">
            <summary><c>long</c> (System.Int64)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.UInt64">
            <summary><c>ulong</c> (System.UInt64)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Single">
            <summary><c>float</c> (System.Single)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Double">
            <summary><c>double</c> (System.Double)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Decimal">
            <summary><c>decimal</c> (System.Decimal)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.DateTime">
            <summary><c>System.DateTime</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.String">
            <summary><c>string</c> (System.String)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Void">
            <summary><c>void</c> (System.Void)</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Type">
            <summary><c>System.Type</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Array">
            <summary><c>System.Array</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Attribute">
            <summary><c>System.Attribute</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.ValueType">
            <summary><c>System.ValueType</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Enum">
            <summary><c>System.Enum</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Delegate">
            <summary><c>System.Delegate</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.MulticastDelegate">
            <summary><c>System.MulticastDelegate</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Exception">
            <summary><c>System.Exception</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.IntPtr">
            <summary><c>System.IntPtr</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.UIntPtr">
            <summary><c>System.UIntPtr</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.IEnumerable">
            <summary><c>System.Collections.IEnumerable</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.IEnumerator">
            <summary><c>System.Collections.IEnumerator</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.IEnumerableOfT">
            <summary><c>System.Collections.Generic.IEnumerable{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.IEnumeratorOfT">
            <summary><c>System.Collections.Generic.IEnumerator{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.IListOfT">
            <summary><c>System.Collections.Generic.IList{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.Task">
            <summary><c>System.Threading.Tasks.Task</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.TaskOfT">
            <summary><c>System.Threading.Tasks.Task{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.NullableOfT">
            <summary><c>System.Nullable{T}</c></summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeCode.IDisposable">
            <summary><c>System.IDisposable</c></summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference">
            <summary>
            Contains well-known type references.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Get(ICSharpCode.NRefactory.TypeSystem.KnownTypeCode)">
            <summary>
            Gets the known type reference for the specified type code.
            Returns null for KnownTypeCode.None.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Object">
            <summary>
            Gets a type reference pointing to the <c>object</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.DBNull">
            <summary>
            Gets a type reference pointing to the <c>System.DBNull</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Boolean">
            <summary>
            Gets a type reference pointing to the <c>bool</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Char">
            <summary>
            Gets a type reference pointing to the <c>char</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.SByte">
            <summary>
            Gets a type reference pointing to the <c>sbyte</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Byte">
            <summary>
            Gets a type reference pointing to the <c>byte</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Int16">
            <summary>
            Gets a type reference pointing to the <c>short</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.UInt16">
            <summary>
            Gets a type reference pointing to the <c>ushort</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Int32">
            <summary>
            Gets a type reference pointing to the <c>int</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.UInt32">
            <summary>
            Gets a type reference pointing to the <c>uint</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Int64">
            <summary>
            Gets a type reference pointing to the <c>long</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.UInt64">
            <summary>
            Gets a type reference pointing to the <c>ulong</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Single">
            <summary>
            Gets a type reference pointing to the <c>float</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Double">
            <summary>
            Gets a type reference pointing to the <c>double</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Decimal">
            <summary>
            Gets a type reference pointing to the <c>decimal</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.DateTime">
            <summary>
            Gets a type reference pointing to the <c>System.DateTime</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.String">
            <summary>
            Gets a type reference pointing to the <c>string</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Void">
            <summary>
            Gets a type reference pointing to the <c>void</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Type">
            <summary>
            Gets a type reference pointing to the <c>System.Type</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Array">
            <summary>
            Gets a type reference pointing to the <c>System.Array</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Attribute">
            <summary>
            Gets a type reference pointing to the <c>System.Attribute</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.ValueType">
            <summary>
            Gets a type reference pointing to the <c>System.ValueType</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Enum">
            <summary>
            Gets a type reference pointing to the <c>System.Enum</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Delegate">
            <summary>
            Gets a type reference pointing to the <c>System.Delegate</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.MulticastDelegate">
            <summary>
            Gets a type reference pointing to the <c>System.MulticastDelegate</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Exception">
            <summary>
            Gets a type reference pointing to the <c>System.Exception</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.IntPtr">
            <summary>
            Gets a type reference pointing to the <c>System.IntPtr</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.UIntPtr">
            <summary>
            Gets a type reference pointing to the <c>System.UIntPtr</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.GenericIList">
            <summary>
            Gets a type reference pointing to the <c>System.Collections.Generic.IList{T}</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.NullableOfT">
            <summary>
            Gets a type reference pointing to the <c>System.Nullable{T}</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.IEnumerable">
            <summary>
            Gets a type reference pointing to the <c>System.Collections.IEnumerable</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.IEnumerator">
            <summary>
            Gets a type reference pointing to the <c>System.Collections.IEnumerator</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.IEnumerableOfT">
            <summary>
            Gets a type reference pointing to the <c>System.Collections.Generic.IEnumerable{T}</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.IEnumeratorOfT">
            <summary>
            Gets a type reference pointing to the <c>System.Collections.Generic.IEnumerator{T}</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.IListOfT">
            <summary>
            Gets a type reference pointing to the <c>System.Collections.Generic.IList{T}</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Task">
            <summary>
            Gets a type reference pointing to the <c>System.Threading.Tasks.Task</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.TaskOfT">
            <summary>
            Gets a type reference pointing to the <c>System.Threading.Tasks.Task{T}</c> type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.IDisposable">
            <summary>
            Gets a type reference pointing to the <c>System.IDisposable</c> type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.GetCSharpNameByTypeCode(ICSharpCode.NRefactory.TypeSystem.KnownTypeCode)">
            <summary>
            Gets the C# primitive type name from the known type code.
            Returns null if there is no primitive name for the specified type.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.NullableType">
            <summary>
            Static helper methods for working with nullable types.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.NullableType.IsNullable(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets whether the specified type is a nullable type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.NullableType.GetUnderlyingType(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Returns the element type, if <paramref name="type"/> is a nullable type.
            Otherwise, returns the type itself.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.NullableType.Create(ICSharpCode.NRefactory.TypeSystem.ICompilation,ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Creates a nullable type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.NullableType.Create(ICSharpCode.NRefactory.TypeSystem.ITypeReference)">
            <summary>
            Creates a nullable type reference.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedType">
            <summary>
            ParameterizedType represents an instance of a generic type.
            Example: List&lt;string&gt;
            </summary>
            <remarks>
            When getting the members, this type modifies the lists so that
            type parameters in the signatures of the members are replaced with
            the type arguments.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ParameterizedType.#ctor(ICSharpCode.NRefactory.TypeSystem.ITypeDefinition,ICSharpCode.NRefactory.TypeSystem.IType[])">
            <summary>
            Fast internal version of the constructor. (no safety checks)
            Keeps the array that was passed and assumes it won't be modified.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ParameterizedType.GetTypeArgument(System.Int32)">
            <summary>
            Same as 'parameterizedType.TypeArguments[index]', but is a bit more efficient (doesn't require the read-only wrapper).
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ParameterizedType.GetSubstitution">
            <summary>
            Gets a type visitor that performs the substitution of class type parameters with the type arguments
            of this parameterized type.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ParameterizedType.GetSubstitution(System.Collections.Generic.IList{ICSharpCode.NRefactory.TypeSystem.IType})">
            <summary>
            Gets a type visitor that performs the substitution of class type parameters with the type arguments
            of this parameterized type,
            and also substitutes method type parameters with the specified method type arguments.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedTypeReference">
            <summary>
            ParameterizedTypeReference is a reference to generic class that specifies the type parameters.
            Example: List&lt;string&gt;
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ParameterListComparer">
            <summary>
            Compares parameter lists by comparing the types of all parameters.
            </summary>
            <remarks>
            'ref int' and 'out int' are considered to be equal.
            "Method{T}(T a)" and "Method{S}(S b)" are also considered equal.
            </remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ParameterListComparer.NormalizeMethodTypeParameters(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Replaces all occurrences of method type parameters in the given type
            by normalized type parameters. This allows comparing parameter types from different
            generic methods.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.SignatureComparer">
            <summary>
            Compares member signatures.
            </summary>
            <remarks>
            This comparer checks for equal short name, equal type parameter count, and equal parameter types (using ParameterListComparer).
            </remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SignatureComparer.Ordinal">
            <summary>
            Gets a signature comparer that uses an ordinal comparison for the member name.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionNameParseException">
            <summary>
            Represents an error while parsing a reflection name.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.TypeKind">
            <summary>
            .
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Other">
            <summary>Language-specific type that is not part of NRefactory.TypeSystem itself.</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Class">
            <summary>A <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/> or <see cref="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedType"/> that is a class.</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Interface">
            <summary>A <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/> or <see cref="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedType"/> that is an interface.</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Struct">
            <summary>A <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/> or <see cref="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedType"/> that is a struct.</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Delegate">
            <summary>A <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/> or <see cref="T:ICSharpCode.NRefactory.TypeSystem.ParameterizedType"/> that is a delegate.</summary>
            <remarks><c>System.Delegate</c> itself is TypeKind.Class</remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Enum">
            <summary>A <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/> that is an enum.</summary>
            <remarks><c>System.Enum</c> itself is TypeKind.Class</remarks>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Module">
            <summary>A <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeDefinition"/> that is a module (VB).</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Void">
            <summary>The <c>System.Void</c> type.</summary>
            <see cref="F:ICSharpCode.NRefactory.TypeSystem.KnownTypeReference.Void"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Unknown">
            <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnknownType"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Null">
            <summary>The type of the null literal.</summary>
            <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.NullType"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Dynamic">
            <summary>Type representing the C# 'dynamic' type.</summary>
            <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.Dynamic"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.UnboundTypeArgument">
            <summary>Represents missing type arguments in partially parameterized types.</summary>
            <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnboundTypeArgument"/>
            <see cref="M:ICSharpCode.NRefactory.TypeSystem.IType.GetNestedTypes(System.Predicate{ICSharpCode.NRefactory.TypeSystem.ITypeDefinition},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.TypeParameter">
            <summary>The type is a type parameter.</summary>
            <see cref="T:ICSharpCode.NRefactory.TypeSystem.ITypeParameter"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Array">
            <summary>An array type</summary>
            <see cref="T:ICSharpCode.NRefactory.TypeSystem.ArrayType"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Pointer">
            <summary>A pointer type</summary>
            <see cref="T:ICSharpCode.NRefactory.TypeSystem.PointerType"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.ByReference">
            <summary>A managed reference type</summary>
            <see cref="T:ICSharpCode.NRefactory.TypeSystem.ByReferenceType"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Anonymous">
            <summary>An anonymous type</summary>
            <see cref="T:ICSharpCode.NRefactory.TypeSystem.AnonymousType"/>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.TypeKind.Intersection">
            <summary>Intersection of several types</summary>
            <see cref="T:ICSharpCode.NRefactory.TypeSystem.IntersectionType"/>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper">
            <summary>
            Static helper methods for reflection names.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.FindType(ICSharpCode.NRefactory.TypeSystem.ICompilation,System.Type)">
            <summary>
            Retrieves the specified type in this compilation.
            Returns <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnknownType"/> if the type cannot be found in this compilation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.FindType(ICSharpCode.NRefactory.TypeSystem.ICompilation,System.String)">
            <summary>
            Retrieves the specified type in this compilation.
            Returns <see cref="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnknownType"/> if the type cannot be found in this compilation.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.ToTypeReference(System.Type)">
            <summary>
            Creates a reference to the specified type.
            </summary>
            <param name="type">The type to be converted.</param>
            <returns>Returns the type reference.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.SplitTypeParameterCountFromReflectionName(System.String)">
            <summary>
            Removes the ` with type parameter count from the reflection name.
            </summary>
            <remarks>Do not use this method with the full name of inner classes.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.SplitTypeParameterCountFromReflectionName(System.String,System.Int32@)">
            <summary>
            Removes the ` with type parameter count from the reflection name.
            </summary>
            <remarks>Do not use this method with the full name of inner classes.</remarks>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.FindType(ICSharpCode.NRefactory.TypeSystem.ICompilation,System.TypeCode)">
            <summary>
            Retrieves a built-in type using the specified type code.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.ToTypeReference(System.TypeCode)">
            <summary>
            Creates a reference to the specified type.
            </summary>
            <param name="typeCode">The type to be converted.</param>
            <returns>Returns the type reference.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.GetTypeCode(ICSharpCode.NRefactory.TypeSystem.IType)">
            <summary>
            Gets the type code for the specified type, or TypeCode.Empty if none of the other type codes match.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.ParseReflectionName(System.String)">
            <summary>
            Parses a reflection name into a type reference.
            </summary>
            <param name="reflectionTypeName">The reflection name of the type.</param>
            <exception cref="T:ICSharpCode.NRefactory.TypeSystem.ReflectionNameParseException">The syntax of the reflection type name is invalid</exception>
            <returns>A type reference that represents the reflection name.</returns>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.Null">
            <summary>
            A reflection class used to represent <c>null</c>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.Dynamic">
            <summary>
            A reflection class used to represent <c>dynamic</c>.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ReflectionHelper.UnboundTypeArgument">
            <summary>
            A reflection class used to represent an unbound type argument.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.SpecialType">
            <summary>
            Contains static implementations of special types.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnknownType">
            <summary>
            Gets the type representing resolve errors.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.NullType">
            <summary>
            The null type is used as type of the null literal. It is a reference type without any members; and it is a subtype of all reference types.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.Dynamic">
            <summary>
            Type representing the C# 'dynamic' type.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.TypeSystem.SpecialType.UnboundTypeArgument">
            <summary>
            A type used for unbound type arguments in partially parameterized types.
            </summary>
            <see cref="M:ICSharpCode.NRefactory.TypeSystem.IType.GetNestedTypes(System.Predicate{ICSharpCode.NRefactory.TypeSystem.ITypeDefinition},ICSharpCode.NRefactory.TypeSystem.GetMemberOptions)"/>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.BinaryReaderWith7BitEncodedInts">
            <summary>
            A binary reader that can read the output of BinaryWriterWith7BitEncodedInts.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.BinaryWriterWith7BitEncodedInts">
            <summary>
            A binary writer that encodes all integers as 7-bit-encoded-ints.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.BitVector16">
            <summary>
            Holds 16 boolean values.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.BusyManager">
            <summary>
            This class is used to prevent stack overflows by representing a 'busy' flag
            that prevents reentrance when another call is running.
            However, using a simple 'bool busy' is not thread-safe, so we use a
            thread-static BusyManager.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.CacheManager">
            <summary>
            Allows caching values for a specific compilation.
            A CacheManager consists of two dictionaries: one for shared instances (shared among all threads working with that resolve context),
            and one for thread-local instances.
            </summary>
            <remarks>This class is thread-safe</remarks>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.CSharpPrimitiveCast">
            <summary>
            Static helper method for converting between primitive types.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.CSharpPrimitiveCast.Cast(System.TypeCode,System.Object,System.Boolean)">
            <summary>
            Performs a conversion between primitive types.
            Unfortunately we cannot use Convert.ChangeType because it has different semantics
            (e.g. rounding behavior for floats, overflow, etc.), so we write down every possible primitive C# cast
            and let the compiler figure out the exact semantics.
            And we have to do everything twice, once in a checked-block, once in an unchecked-block.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.ExtensionMethods">
            <summary>
            Contains extension methods for use within NRefactory.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.FastSerializer.EmitScanField(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder,System.Reflection.FieldInfo)">
            <summary>
            Emit 'scan instance.Field'.
            Stack transition: ... => ...
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.FastSerializer.EmitScanValueType(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
            Stack transition: ..., value => ...
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.FastSerializer.EmitWriteField(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder,System.Reflection.Emit.LocalBuilder,System.Reflection.FieldInfo)">
            <summary>
            Emit 'write instance.Field'.
            Stack transition: ... => ...
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.FastSerializer.WritePrimitiveValue(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
            Writes a primitive value of the specified type.
            Stack transition: ..., writer, value => ...
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.FastSerializer.EmitWriteValueType(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder,System.Type)">
            <summary>
            Stack transition: ..., value => ...
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.FastSerializer.ReadPrimitiveValue(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder,System.Type)">
            <summary>
            Reads a primitive value of the specified type.
            Stack transition: ... => ..., value
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.FastSerializer.EmitReadValueType(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder,System.Type)">
            <summary>
            Stack transition: ..., field-ref => ...
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Utils.FastSerializer.SerializationBinder">
            <summary>
            Gets/Sets the serialization binder that is being used.
            The default value is null, which will cause the FastSerializer to use the
            full assembly and type names.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.Utils.FastSerializer.FixedInstances">
            <summary>
            Can be used to set several 'fixed' instances.
            When serializing, such instances will not be included; and any references to a fixed instance
            will be stored as the index in this array.
            When deserializing, the same (or equivalent) instances must be specified, and the deserializer
            will use them in place of the fixed instances.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.FastSerializer.SerializationContext.Mark(System.Object)">
            <summary>
            Marks an instance for future scanning.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.GraphVizGraph">
            <summary>
            GraphViz graph.
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizEdge.color">
            <summary>edge stroke color</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizEdge.constraint">
            <summary>use edge to affect node ranking</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizEdge.fontsize">
            <summary>point size of label</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizNode.fontsize">
            <summary>point size of label</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizNode.height">
            <summary>minimum height in inches</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizNode.margin">
            <summary>space around label</summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.GraphVizNode.shape">
            <summary>node shape</summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.ImmutableStack`1">
            <summary>
            An immutable stack.
            
            Using 'foreach' on the stack will return the items from top to bottom (in the order they would be popped).
            </summary>
        </member>
        <member name="F:ICSharpCode.NRefactory.Utils.ImmutableStack`1.Empty">
            <summary>
            Gets the empty stack instance.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.ImmutableStack`1.Push(`0)">
            <summary>
            Pushes an item on the stack. This does not modify the stack itself, but returns a new
            one with the value pushed.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.ImmutableStack`1.Peek">
            <summary>
            Gets the item on the top of the stack.
            </summary>
            <exception cref="T:System.InvalidOperationException">The stack is empty.</exception>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.ImmutableStack`1.PeekOrDefault">
            <summary>
            Gets the item on the top of the stack.
            Returns <c>default(T)</c> if the stack is empty.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.ImmutableStack`1.Pop">
            <summary>
            Gets the stack with the top item removed.
            </summary>
            <exception cref="T:System.InvalidOperationException">The stack is empty.</exception>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.ImmutableStack`1.GetEnumerator">
            <summary>
            Gets an enumerator that iterates through the stack top-to-bottom.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.ImmutableStack`1.ToString">
            <inheritdoc/>
        </member>
        <member name="P:ICSharpCode.NRefactory.Utils.ImmutableStack`1.IsEmpty">
            <summary>
            Gets if this stack is empty.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.LazyInit.GetOrSet``1(``0@,``0)">
            <summary>
            Atomatically performs the following operation:
            - If target is null: stores newValue in target and returns newValue.
            - If target is not null: returns target.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.Platform">
            <summary>
            Platform-specific code.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.Utils.TreeTraversal">
            <summary>
            Static helper methods for traversing trees.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.TreeTraversal.PreOrder``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts a tree data structure into a flat list by traversing it in pre-order.
            </summary>
            <param name="root">The root element of the tree.</param>
            <param name="recursion">The function that gets the children of an element.</param>
            <returns>Iterator that enumerates the tree structure in pre-order.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.TreeTraversal.PreOrder``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts a tree data structure into a flat list by traversing it in pre-order.
            </summary>
            <param name="input">The root elements of the forest.</param>
            <param name="recursion">The function that gets the children of an element.</param>
            <returns>Iterator that enumerates the tree structure in pre-order.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.TreeTraversal.PostOrder``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts a tree data structure into a flat list by traversing it in post-order.
            </summary>
            <param name="root">The root element of the tree.</param>
            <param name="recursion">The function that gets the children of an element.</param>
            <returns>Iterator that enumerates the tree structure in post-order.</returns>
        </member>
        <member name="M:ICSharpCode.NRefactory.Utils.TreeTraversal.PostOrder``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts a tree data structure into a flat list by traversing it in post-order.
            </summary>
            <param name="input">The root elements of the forest.</param>
            <param name="recursion">The function that gets the children of an element.</param>
            <returns>Iterator that enumerates the tree structure in post-order.</returns>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.ErrorType">
            <summary>
            Enum that describes the type of an error.
            </summary>
        </member>
        <member name="T:ICSharpCode.NRefactory.TypeSystem.Error">
            <summary>
            Descibes an error during parsing.
            </summary>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Error.#ctor(ICSharpCode.NRefactory.TypeSystem.ErrorType,System.String,ICSharpCode.NRefactory.TypeSystem.DomRegion)">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.NRefactory.TypeSystem.Error"/> class.
            </summary>
            <param name="errorType">
            The error type.
            </param>
            <param name="message">
            The description of the error.
            </param>
            <param name="region">
            The region of the error.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Error.#ctor(ICSharpCode.NRefactory.TypeSystem.ErrorType,System.String,ICSharpCode.NRefactory.TextLocation)">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.NRefactory.TypeSystem.Error"/> class.
            </summary>
            <param name="errorType">
            The error type.
            </param>
            <param name="message">
            The description of the error.
            </param>
            <param name="location">
            The location of the error.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Error.#ctor(ICSharpCode.NRefactory.TypeSystem.ErrorType,System.String,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.NRefactory.TypeSystem.Error"/> class.
            </summary>
            <param name="errorType">
            The error type.
            </param>
            <param name="message">
            The description of the error.
            </param>
            <param name="line">
            The line of the error.
            </param>
            <param name="col">
            The column of the error.
            </param>
        </member>
        <member name="M:ICSharpCode.NRefactory.TypeSystem.Error.#ctor(ICSharpCode.NRefactory.TypeSystem.ErrorType,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ICSharpCode.NRefactory.TypeSystem.Error"/> class.
            </summary>
            <param name="errorType">
            The error type.
            </param>
            <param name="message">
            The description of the error.
            </param>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Error.ErrorType">
            <summary>
            The type of the error.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Error.Message">
            <summary>
            The error description.
            </summary>
        </member>
        <member name="P:ICSharpCode.NRefactory.TypeSystem.Error.Region">
            <summary>
            The region of the error.
            </summary>
        </member>
    </members>
</doc>

// Based on Jeff Wilcox' Syntax highlighter: http://www.jeff.wilcox.name/2010/03/syntax-highlighting-text-block/
// He really deservces most of the credits...

// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.
// <auto-generated />
// No style analysis for imported project.

namespace Raven.Studio.Controls.JeffWilcox.SyntaxHighlighting
{
	using System.Collections.Generic;
	using System.Windows;
	using System.Windows.Controls;
	using System.Windows.Documents;
	using System.Windows.Media;

	// CONSIDER: background worker to improve performance, with all UI
	// generation at the end.

	class XamlInlineFormatter : IFormatter
	{
		readonly TextBlock _text;

		public XamlInlineFormatter(Panel panel) : this()
		{
			_text = new TextBlock {TextWrapping = TextWrapping.Wrap};
			panel.Children.Add(_text);
		}

		/// <summary>
		/// Initializes a new instance of the XAML inline formatter which will
		/// store the contents of the syntax highlighting results into the
		/// text block instance.
		/// </summary>
		/// <param name="textBlock">The text block.</param>
		public XamlInlineFormatter(TextBlock textBlock)
			: this()
		{
			_text = textBlock;
		}

		protected XamlInlineFormatter()
		{
		}

		public void Write(string parsedSourceCode,
		                  IList<Scope> scopes,
		                  IStyleSheet styleSheet)
		{
			var styleInsertions = new List<TextInsertion>();

			int offset = 0;
			bool lastScopeWasComment = false;
			int lastoffset = 0;
			foreach (Scope scope in scopes)
			{
				if (lastoffset < scope.Index)
				{
					string space = parsedSourceCode.Substring(lastoffset, scope.Index - lastoffset);
					Inline run = new Run {Text = space.Replace("\r", string.Empty)};
					_text.Inlines.Add(run);
				}
				string t = parsedSourceCode.Substring(scope.Index, scope.Length);
				lastoffset = scope.Index + scope.Length;
//                    .Replace("\r\n", "\n")
//                    .Replace("\r", "\n");
				offset = scope.Index + scope.Length;
				if (!string.IsNullOrEmpty(t))
				{
					Inline run = new Run {Text = t.Replace("\r", string.Empty)};
					if (scope != null && styleSheet.Styles.Contains(scope.Name))
					{
						Style style = styleSheet.Styles[scope.Name];
						run.Foreground = new SolidColorBrush(style.Foreground);
					}
					lastScopeWasComment = (scope != null && scope.Name == "Comment");
					_text.Inlines.Add(run);
				}
			}
			string left = parsedSourceCode
				.Substring(offset)
				.Replace("\r\n", "\n")
				.Replace("\r", "\n");
			if (!string.IsNullOrEmpty(left))
			{
				for (int i = left.IndexOf("\n"); i >= 0; i = left.IndexOf("\n"))
				{
					if (i > 0)
					{
						Inline tby = new Run {Text = left.Substring(0, i)};
						_text.Inlines.Add(tby);
					}

					left = left.Substring(i + 1);
					if (lastScopeWasComment)
					{
						lastScopeWasComment = false;
					}
					else
					{
						_text.Inlines.Add(new LineBreak());
					}
				}

				if (!string.IsNullOrEmpty(left))
				{
					Inline nrun = new Run {Text = left};
					_text.Inlines.Add(nrun);
				}
			}
		}

		static void GetStyleInsertionsForCapturedStyle(Scope scope, ICollection<TextInsertion> styleInsertions)
		{
			styleInsertions.Add(new TextInsertion
			                    	{
			                    		Index = scope.Index,
			                    		Scope = scope
			                    	});

			foreach (Scope childScope in scope.Children)
				GetStyleInsertionsForCapturedStyle(childScope, styleInsertions);

			styleInsertions.Add(new TextInsertion
			                    	{
			                    		Index = scope.Index + scope.Length,
			                    		//                Text = ""
			                    	});
		}

		static void BuildSpanForCapturedStyle(Scope scope,
		                                      IStyleSheet styleSheet)
		{
			Color foreground = Colors.Black;
			Color background = Colors.Transparent;

			if (styleSheet.Styles.Contains(scope.Name))
			{
				Style style = styleSheet.Styles[scope.Name];

				foreground = style.Foreground;
				background = style.Background;
			}

			WriteElementStart("span", foreground, background);
		}

		static void WriteHeaderDivEnd()
		{
			WriteElementEnd("div");
		}

		static void WriteElementEnd(string elementName)
		{
		}

		static void WriteHeaderPreEnd()
		{
			WriteElementEnd("pre");
		}

		static void WriteHeaderPreStart()
		{
			WriteElementStart("pre");
		}

		static void WriteHeaderDivStart(IStyleSheet styleSheet)
		{
			Color foreground = Colors.Transparent;
			Color background = Colors.Transparent;

			if (styleSheet.Styles.Contains(ScopeName.PlainText))
			{
				Style plainTextStyle = styleSheet.Styles[ScopeName.PlainText];

				foreground = plainTextStyle.Foreground;
				background = plainTextStyle.Background;
			}

			WriteElementStart("div", foreground, background);
		}

		static void WriteElementStart(string elementName)
		{
			WriteElementStart(elementName, Colors.Transparent, Colors.Transparent);
		}

		static void WriteElementStart(string elementName,
		                              Color foreground,
		                              Color background)
		{
			if (foreground != Colors.Transparent || background != Colors.Transparent)
			{
			}
		}
	}
}
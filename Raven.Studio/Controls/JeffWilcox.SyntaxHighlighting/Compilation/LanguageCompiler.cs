// Based on Jeff Wilcox' Syntax highlighter: http://www.jeff.wilcox.name/2010/03/syntax-highlighting-text-block/
// He really deservces most of the credits...

// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.
// <auto-generated />
// No style analysis for imported project.

namespace Raven.Studio.Controls.JeffWilcox.SyntaxHighlighting
{
	using System;
	using System.Collections.Generic;
	using System.Text;
	using System.Text.RegularExpressions;

	class LanguageCompiler : ILanguageCompiler
	{
		static readonly Regex numberOfCapturesRegex = new Regex(@"(?x)(?<!\\)\((?!\?)"); // , RegexOptions.);
		readonly Dictionary<string, CompiledLanguage> compiledLanguages;

		public LanguageCompiler(Dictionary<string, CompiledLanguage> compiledLanguages)
		{
			this.compiledLanguages = compiledLanguages;
		}

		public CompiledLanguage Compile(ILanguage language)
		{
			Guard.ArgNotNull(language, "language");

			if (string.IsNullOrEmpty(language.Id))
				throw new ArgumentException("The language identifier must not be null.", "language");

			CompiledLanguage compiledLanguage;

			try
			{
				// for performance reasons we should first try with
				// only a read lock since the majority of the time
				// it'll be created already and upgradeable lock blocks
				if (compiledLanguages.ContainsKey(language.Id))
					return compiledLanguages[language.Id];
			}
			finally
			{
			}

			try
			{
				if (compiledLanguages.ContainsKey(language.Id))
					compiledLanguage = compiledLanguages[language.Id];
				else
				{
					try
					{
						if (string.IsNullOrEmpty(language.Name))
							throw new ArgumentException("The language name must not be null or empty.", "language");

						if (language.Rules == null || language.Rules.Count == 0)
							throw new ArgumentException("The language rules collection must not be empty.", "language");

						compiledLanguage = CompileLanguage(language);

						compiledLanguages.Add(compiledLanguage.Id, compiledLanguage);
					}
					finally
					{
					}
				}
			}
			finally
			{
			}

			return compiledLanguage;
		}

		static CompiledLanguage CompileLanguage(ILanguage language)
		{
			string id = language.Id;
			string name = language.Name;
			Regex regex;
			IList<string> captures;

			CompileRules(language.Rules, out regex, out captures);

			return new CompiledLanguage(id, name, regex, captures);
		}

		static void CompileRules(IList<LanguageRule> rules,
		                         out Regex regex,
		                         out IList<string> captures)
		{
			var regexBuilder = new StringBuilder();
			captures = new List<string>();

			regexBuilder.AppendLine("(?x)");
			captures.Add(null);

			CompileRule(rules[0], regexBuilder, captures, true);

			for (int i = 1; i < rules.Count; i++)
				CompileRule(rules[i], regexBuilder, captures, false);

			regex = new Regex(regexBuilder.ToString());
		}


		static void CompileRule(LanguageRule languageRule,
		                        StringBuilder regex,
		                        ICollection<string> captures,
		                        bool isFirstRule)
		{
			if (!isFirstRule)
			{
				regex.AppendLine();
				regex.AppendLine();
				regex.AppendLine("|");
				regex.AppendLine();
			}

			regex.AppendFormat("(?-xis)(?m)({0})(?x)", languageRule.Regex);

			int numberOfCaptures = GetNumberOfCaptures(languageRule.Regex);

			for (int i = 0; i <= numberOfCaptures; i++)
			{
				string scope = null;

				foreach (int captureIndex in languageRule.Captures.Keys)
				{
					if (i == captureIndex)
					{
						scope = languageRule.Captures[captureIndex];
						break;
					}
				}

				captures.Add(scope);
			}
		}

		static int GetNumberOfCaptures(string regex)
		{
			return numberOfCapturesRegex.Matches(regex).Count;
		}
	}
}
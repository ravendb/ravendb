<?xml version="1.0" encoding="utf-8"?>
<!--

Actipro Syntax Language Definition (.langdef)
  For use with Actipro SyntaxEditor and related products.
  http://www.actiprosoftware.com

'C#' language created by Actipro Software LLC.
  Copyright (c) 2001-2011 Actipro Software LLC.  All rights reserved.

-->
<LanguageDefinition LanguageKey="CSharp" LanguageDescription="C#" Creator="Actipro Software LLC" Copyright="Copyright (c) 2001-2011 Actipro Software LLC.  All rights reserved." xmlns="http://schemas.actiprosoftware.com/langdef/1.0">
	<!-- Classification types -->
	<LanguageDefinition.ClassificationTypes>
		<ClassificationType Key="Keyword" DefaultStyle="#FF0000FF" />
		<ClassificationType Key="Identifier" />
		<ClassificationType Key="Operator" />
		<ClassificationType Key="Number" />
		<ClassificationType Key="String" DefaultStyle="#FF800000" />
		<ClassificationType Key="CSharpVerbatimString" Description="String (C# @ Verbatim)" DefaultStyle="#FF800000" />
		<ClassificationType Key="Comment" DefaultStyle="#FF008000" />
		<ClassificationType Key="XmlDocumentationTag" Description="XML Doc Tag" DefaultStyle="#FF808080" />
		<ClassificationType Key="XmlDocumentationComment" Description="XML Doc Comment" DefaultStyle="#FF008000" />
		<ClassificationType Key="PreprocessorKeyword" Description="Preprocessor Keyword" DefaultStyle="#FF0000FF" />
	</LanguageDefinition.ClassificationTypes>
	<!-- Lexer -->
	<LanguageDefinition.Lexer>
		<DynamicLexer>
			<!-- Default state -->
			<State Key="Default" DefaultCaseSensitivity="Sensitive">
				<State.ChildStates>
					<StateRef Key="Character" />
					<StateRef Key="String" />
					<StateRef Key="MultiLineComment" />
					<StateRef Key="XmlComment" />
					<StateRef Key="Comment" />
					<StateRef Key="VerbatimString" />
					<StateRef Key="PreprocessorDirective" />
				</State.ChildStates>
				<RegexPatternGroup TokenKey="Whitespace" Pattern="{Whitespace}+" />
				<RegexPatternGroup TokenKey="LineTerminator" Pattern="{LineTerminator}" />
				<ExplicitPatternGroup Key="OpenParenthesisPatternGroup" TokenKey="OpenParenthesis" Pattern="(" />
				<ExplicitPatternGroup Key="CloseParenthesisPatternGroup" TokenKey="CloseParenthesis" Pattern=")" />
				<ExplicitPatternGroup Key="OpenCurlyBracePatternGroup" TokenKey="OpenCurlyBrace" Pattern="{" />
				<ExplicitPatternGroup Key="CloseCurlyBracePatternGroup" TokenKey="CloseCurlyBrace" Pattern="}" />
				<ExplicitPatternGroup Key="OpenSquareBracePatternGroup" TokenKey="OpenSquareBrace" Pattern="[" />
				<ExplicitPatternGroup Key="CloseSquareBracePatternGroup" TokenKey="CloseSquareBrace" Pattern="]" />
				<ExplicitPatternGroup TokenKey="Punctuation">
					<ExplicitPatterns><![CDATA[
						. , : ;
					]]></ExplicitPatterns>
				</ExplicitPatternGroup>
				<ExplicitPatternGroup TokenKey="Null" ClassificationTypeKey="Keyword" Pattern="null" LookAheadPattern="{NonWord}|\z" />
				<ExplicitPatternGroup TokenKey="NativeType" ClassificationTypeKey="Keyword" LookAheadPattern="{NonWord}|\z">
					<ExplicitPatterns><![CDATA[
						object bool string int byte char float sbyte short long ushort uint ulong double decimal
					]]></ExplicitPatterns>
				</ExplicitPatternGroup>
				<ExplicitPatternGroup TokenKey="Boolean" ClassificationTypeKey="Keyword" LookAheadPattern="{NonWord}|\z">
					<ExplicitPatterns><![CDATA[
						false true
					]]></ExplicitPatterns>
				</ExplicitPatternGroup>
				<ExplicitPatternGroup TokenKey="ReservedWord" ClassificationTypeKey="Keyword" LookAheadPattern="{NonWord}|\z">
					<ExplicitPatterns><![CDATA[
						as break case catch class else for foreach get abstract base checked const continue default delegate
						do enum event explicit extern finally fixed global goto if in internal is new private protected public
						return implicit interface lock namespace operator out override params partial readonly ref this
						try typeof sealed set sizeof stackalloc static struct switch throw unchecked unsafe using virtual
						void volatile where while yield
					]]></ExplicitPatterns>
				</ExplicitPatternGroup>
				<ExplicitPatternGroup TokenKey="ReservedContextualWord" ClassificationTypeKey="Keyword" LookBehindPattern="^|[^\.]" LookAheadPattern="{NonWord}|\z">
					<ExplicitPatterns><![CDATA[
						ascending by descending equals from group into join let on orderby select where var
					]]></ExplicitPatterns>
				</ExplicitPatternGroup>
				<RegexPatternGroup TokenKey="Identifier" ClassificationTypeKey="Identifier" Pattern="@? (_ | {Alpha})({Word})*" />
				<ExplicitPatternGroup TokenKey="Operator" ClassificationTypeKey="Operator">
					<ExplicitPatterns><![CDATA[
						== != = ! ++ -- += -= *= /= %= -> + - * / % && || &= |= ^= & | ~ ^ <<= >>= << >> <= < >= > ?? ?
					]]></ExplicitPatterns>
				</ExplicitPatternGroup>
				<RegexPatternGroup TokenKey="RealNumber" ClassificationTypeKey="Number" LookAheadPattern="{NonWord}|\z">
					<RegexPattern Value="{Digit}* \. {Digit}+ ([Ee] [\+\-]? {Digit}+)? [FfDdMm]?" />
					<RegexPattern Value="{Digit}+ [Ee] [\+\-]? {Digit}+ [FfDdMm]" />
				</RegexPatternGroup>
				<RegexPatternGroup TokenKey="IntegerNumber" ClassificationTypeKey="Number" Pattern="{Digit}+ (([Uu]? [Ll]?) | ([Ll]? [Uu]?))" LookAheadPattern="{NonWord}|\z" />
				<RegexPatternGroup TokenKey="HexIntegerNumber" ClassificationTypeKey="Number" Pattern="0 [xX] {HexDigit}+ (([Uu]? [Ll]?) | ([Ll]? [Uu]?))" LookAheadPattern="{NonWord}|\z" />
			</State>
			<!-- Character state -->
			<State Key="Character" DefaultTokenKey="CharacterText" DefaultClassificationTypeKey="String">
				<State.Scopes>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="CharacterStartDelimiter" Pattern="'" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<RegexPatternGroup TokenKey="CharacterEndDelimiter" Pattern="['\n]" />
						</Scope.EndPatternGroup>
					</Scope>
				</State.Scopes>
				<RegexPatternGroup TokenKey="CharacterEscapedCharacter" Pattern="\\x {HexDigit}{1,4}" />
				<RegexPatternGroup TokenKey="CharacterEscapedCharacter" Pattern="\\u {HexDigit}{4,4}" />
				<RegexPatternGroup TokenKey="CharacterEscapedCharacter" Pattern="\\U {HexDigit}{8,8}" />
				<RegexPatternGroup TokenKey="CharacterEscapedCharacter" Pattern="\\." />
				<RegexPatternGroup TokenKey="CharacterText" Pattern="[^'\\\n]+" />
			</State>
			<!-- String state -->
			<State Key="String" DefaultTokenKey="StringText" DefaultClassificationTypeKey="String">
				<State.Scopes>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="StringStartDelimiter" Pattern="&quot;" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<RegexPatternGroup TokenKey="StringEndDelimiter" Pattern="[\&quot;\n]" />
						</Scope.EndPatternGroup>
					</Scope>
				</State.Scopes>
				<RegexPatternGroup TokenKey="StringEscapedCharacter" Pattern="\\x {HexDigit}{1,4}" />
				<RegexPatternGroup TokenKey="StringEscapedCharacter" Pattern="\\u {HexDigit}{4,4}" />
				<RegexPatternGroup TokenKey="StringEscapedCharacter" Pattern="\\U {HexDigit}{8,8}" />
				<RegexPatternGroup TokenKey="StringEscapedCharacter" Pattern="\\." />
				<RegexPatternGroup TokenKey="StringText" Pattern="[^\&quot;\\\n]+" />
			</State>
			<!-- VerbatimString state -->
			<State Key="VerbatimString" DefaultTokenKey="VerbatimStringText" DefaultClassificationTypeKey="CSharpVerbatimString">
				<State.Scopes>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="VerbatimStringStartDelimiter" Pattern="@&quot;" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<ExplicitPatternGroup TokenKey="VerbatimStringEndDelimiter" Pattern="&quot;" />
						</Scope.EndPatternGroup>
					</Scope>
				</State.Scopes>
				<ExplicitPatternGroup TokenKey="VerbatimStringEscapedDelimiter" Pattern="&quot;&quot;" />
				<RegexPatternGroup TokenKey="VerbatimStringLineTerminator" Pattern="\n" />
				<RegexPatternGroup TokenKey="VerbatimStringText" Pattern="[^\&quot;\n]+" />
			</State>
			<!-- Comment state -->
			<State Key="Comment" DefaultTokenKey="CommentText" DefaultClassificationTypeKey="Comment">
				<State.Scopes>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="CommentStartDelimiter" Pattern="//" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<RegexPatternGroup TokenKey="CommentEndDelimiter" Pattern="{LineTerminator}" />
						</Scope.EndPatternGroup>
					</Scope>
				</State.Scopes>
				<RegexPatternGroup TokenKey="CommentLineTerminator" Pattern="{LineTerminator} {Whitespace}* // [^/]" />
				<RegexPatternGroup TokenKey="CommentText" Pattern="[^\n]+" />
			</State>
			<!-- MultiLineComment state -->
			<State Key="MultiLineComment" DefaultTokenKey="MultiLineCommentText" DefaultClassificationTypeKey="Comment">
				<State.Scopes>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="MultiLineCommentStartDelimiter" Pattern="/*" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<ExplicitPatternGroup TokenKey="MultiLineCommentEndDelimiter" Pattern="*/" />
						</Scope.EndPatternGroup>
					</Scope>
				</State.Scopes>
				<RegexPatternGroup TokenKey="MultiLineCommentLineTerminator" Pattern="{LineTerminator}" />
				<RegexPatternGroup TokenKey="MultiLineCommentText" Pattern="[^*\n]+" />
			</State>
			<!-- XmlComment state -->
			<State Key="XmlComment" DefaultTokenKey="XmlCommentText" DefaultClassificationTypeKey="XmlDocumentationComment">
				<State.Scopes>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="XmlCommentStartDelimiter" Pattern="///" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<RegexPatternGroup TokenKey="XmlCommentEndDelimiter" Pattern="{LineTerminator}" />
						</Scope.EndPatternGroup>
					</Scope>
				</State.Scopes>
				<RegexPatternGroup TokenKey="XmlCommentStartTag" ClassificationTypeKey="XmlDocumentationTag" Pattern="&lt; [^\n&gt;]* &gt;?" />
				<RegexPatternGroup TokenKey="XmlCommentEndTag" ClassificationTypeKey="XmlDocumentationTag" Pattern="&lt;/ [^\n&gt;]* &gt;?" />
				<RegexPatternGroup TokenKey="XmlCommentLineTerminator" Pattern="{LineTerminator} {LineTerminatorWhitespace}* ///" />
				<RegexPatternGroup TokenKey="XmlCommentText" Pattern="[^\n&lt;]+" />
			</State>
			<!-- PreprocessorDirective state -->
			<State Key="PreprocessorDirective" DefaultTokenKey="PreprocessorDirectiveText" DefaultCaseSensitivity="Sensitive">
				<State.Scopes>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="RegionPreprocessorDirective" ClassificationTypeKey="PreprocessorKeyword" Pattern="#region" LookAheadPattern="{NonWord}|\z" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<RegexPatternGroup TokenKey="PreprocessorDirectiveEndDelimiter" Pattern="{LineTerminator}" />
						</Scope.EndPatternGroup>
					</Scope>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="EndRegionPreprocessorDirective" ClassificationTypeKey="PreprocessorKeyword" Pattern="#endregion" LookAheadPattern="{NonWord}|\z" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<RegexPatternGroup TokenKey="PreprocessorDirectiveEndDelimiter" Pattern="{LineTerminator}" />
						</Scope.EndPatternGroup>
					</Scope>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="DefinePreprocessorDirective" ClassificationTypeKey="PreprocessorKeyword" Pattern="#define" LookAheadPattern="{NonWord}|\z" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<RegexPatternGroup TokenKey="PreprocessorDirectiveEndDelimiter" Pattern="{LineTerminator}" />
						</Scope.EndPatternGroup>
					</Scope>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="UndefPreprocessorDirective" ClassificationTypeKey="PreprocessorKeyword" Pattern="#undef" LookAheadPattern="{NonWord}|\z" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<RegexPatternGroup TokenKey="PreprocessorDirectiveEndDelimiter" Pattern="{LineTerminator}" />
						</Scope.EndPatternGroup>
					</Scope>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="IfPreprocessorDirectiveIf" ClassificationTypeKey="PreprocessorKeyword" Pattern="#if" LookAheadPattern="{NonWord}|\z" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<RegexPatternGroup TokenKey="PreprocessorDirectiveEndDelimiter" Pattern="{LineTerminator}" />
						</Scope.EndPatternGroup>
					</Scope>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="IfPreprocessorDirectiveElIf" ClassificationTypeKey="PreprocessorKeyword" Pattern="#elif" LookAheadPattern="{NonWord}|\z" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<RegexPatternGroup TokenKey="PreprocessorDirectiveEndDelimiter" Pattern="{LineTerminator}" />
						</Scope.EndPatternGroup>
					</Scope>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="IfPreprocessorDirectiveElse" ClassificationTypeKey="PreprocessorKeyword" Pattern="#else" LookAheadPattern="{NonWord}|\z" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<RegexPatternGroup TokenKey="PreprocessorDirectiveEndDelimiter" Pattern="{LineTerminator}" />
						</Scope.EndPatternGroup>
					</Scope>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="IfPreprocessorDirectiveEndIf" ClassificationTypeKey="PreprocessorKeyword" Pattern="#endif" LookAheadPattern="{NonWord}|\z" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<RegexPatternGroup TokenKey="PreprocessorDirectiveEndDelimiter" Pattern="{LineTerminator}" />
						</Scope.EndPatternGroup>
					</Scope>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="LinePreprocessorDirective" ClassificationTypeKey="PreprocessorKeyword" Pattern="#line" LookAheadPattern="{NonWord}|\z" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<RegexPatternGroup TokenKey="PreprocessorDirectiveEndDelimiter" Pattern="{LineTerminator}" />
						</Scope.EndPatternGroup>
					</Scope>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="PragmaPreprocessorDirective" ClassificationTypeKey="PreprocessorKeyword" Pattern="#pragma" LookAheadPattern="{NonWord}|\z" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<RegexPatternGroup TokenKey="PreprocessorDirectiveEndDelimiter" Pattern="{LineTerminator}" />
						</Scope.EndPatternGroup>
					</Scope>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="WarningPreprocessorDirective" ClassificationTypeKey="PreprocessorKeyword" Pattern="#warning" LookAheadPattern="{NonWord}|\z" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<RegexPatternGroup TokenKey="PreprocessorDirectiveEndDelimiter" Pattern="{LineTerminator}" />
						</Scope.EndPatternGroup>
					</Scope>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="ErrorPreprocessorDirective" ClassificationTypeKey="PreprocessorKeyword" Pattern="#error" LookAheadPattern="{NonWord}|\z" />
						</Scope.StartPatternGroup>
						<Scope.EndPatternGroup>
							<RegexPatternGroup TokenKey="PreprocessorDirectiveEndDelimiter" Pattern="{LineTerminator}" />
						</Scope.EndPatternGroup>
					</Scope>
				</State.Scopes>
				<State.ChildStates>
					<StateRef Key="PreprocessorDirectiveComment" />
				</State.ChildStates>
				<RegexPatternGroup Pattern="[^/\n]+" />
			</State>
			<!-- PreprocessorDirectiveComment state -->
			<State Key="PreprocessorDirectiveComment" DefaultTokenKey="CommentText" DefaultClassificationTypeKey="Comment">
				<State.Scopes>
					<Scope>
						<Scope.StartPatternGroup>
							<ExplicitPatternGroup TokenKey="CommentStartDelimiter" Pattern="//" />
						</Scope.StartPatternGroup>
					</Scope>
				</State.Scopes>
				<RegexPatternGroup TokenKey="CommentDefault" Pattern="{NonLineTerminator}+" />
			</State>
		</DynamicLexer>
	</LanguageDefinition.Lexer>
	<!-- Example text -->
	<LanguageDefinition.ExampleText><![CDATA[using System;

public class Foo {

	/// <summary>
	/// This is an <c>XML</c> documentation comment.
	/// </summary>
	public static void Main(string[] args) {
		Console.WriteLine("Hello, World!");
		Console.WriteLine("You entered the following {0} command line arguments:", args.Length);
		for (int i = 0; i < args.Length; i++)
			Console.WriteLine("{0}", args[i]); 
	
	}
}
]]></LanguageDefinition.ExampleText>
</LanguageDefinition>